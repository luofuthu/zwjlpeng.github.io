<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>烟雨林</title><link href="http://www.yanyulin.info/" rel="alternate"></link><link href="http://www.yanyulin.info/feeds/bian-cheng-yu-yan.atom.xml" rel="self"></link><id>http://www.yanyulin.info/</id><updated>2014-03-15T00:00:00+08:00</updated><entry><title>Velocity入门教程HelloWord程序</title><link href="http://www.yanyulin.info/pages/2014/03/velocity_disabuse_1.html" rel="alternate"></link><updated>2014-03-15T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2014-03-15:pages/2014/03/velocity_disabuse_1.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Velocity&lt;/code&gt;是&lt;code&gt;Apache&lt;/code&gt;公司的开源产品，是一套基于&lt;code&gt;Java&lt;/code&gt;语言的模板引擎，可以很灵活的将后台数据对象与模板文件结合在一起，说的直白一点，就是允许任何人使用模板语言引用后台java代码定义的对象&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Velocity&lt;/code&gt;应用于Web开发时，界面设计人员可以和java程序开发人员同步开发一个遵循MVC架构的web站点，也就是说，页面设计人员可以只关注页面的显示效果，而由Java程序开发人员关注业务逻辑编码&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Velocity&lt;/code&gt;将 java代码从web页面中分离出来，这样为web站点的长期维护提供了便利,之所以写这篇文章，是因为在淘宝实习，淘宝的WebX框架也使用了&lt;code&gt;Velocity&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;入门例子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Velocity&lt;/code&gt;应用于&lt;code&gt;java&lt;/code&gt;工程时，创建完一个普通的java工程后，需要引入相应的jar包，才能让工程支持&lt;code&gt;Velocity&lt;/code&gt;模板引擎(velocity-1.7.jar/ commons-*.jar)&lt;/p&gt;
&lt;p&gt;如下是例子一&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;VelJava工程的后台java代码&lt;/span&gt;&lt;span class="sb"&gt;`VelJava.java`&lt;/span&gt;

&lt;span class="c1"&gt;//构造函数  &lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;VelJava&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="nx"&gt;throws&lt;/span&gt; &lt;span class="nx"&gt;IOException&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="c1"&gt;//初始化Velocity模板  &lt;/span&gt;
    &lt;span class="nx"&gt;Velocity.init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
    &lt;span class="c1"&gt;//创建一个VeloctiyContext对象  &lt;/span&gt;
    &lt;span class="nx"&gt;VelocityContext&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;VelocityContext&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
    &lt;span class="c1"&gt;//向VelocityContext对象中放入一个键值对  &lt;/span&gt;
    &lt;span class="nx"&gt;context.put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;list&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="na"&gt;getNames&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;  
    &lt;span class="nx"&gt;Template&lt;/span&gt; &lt;span class="n"&gt;template&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="kt"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="c1"&gt;//通过静态方法获取一个模板  &lt;/span&gt;
    &lt;span class="n"&gt;template&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nx"&gt;Velocity.getTemplate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;test.vm&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="c1"&gt;//创建一个输出流  &lt;/span&gt;
    &lt;span class="nx"&gt;BufferedWriter&lt;/span&gt; &lt;span class="n"&gt;writer&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;BufferedWriter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;OutputStreamWriter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;System.out&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;  
    &lt;span class="c1"&gt;//将模板与context中的对象结合，然后输出  &lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;template&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="kt"&gt;null&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
        &lt;span class="nx"&gt;template.merge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;writer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="c1"&gt;//刷新缓存  &lt;/span&gt;
    &lt;span class="nx"&gt;writer.flush&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
    &lt;span class="c1"&gt;//关闭writer  &lt;/span&gt;
    &lt;span class="nx"&gt;writer.close&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="c1"&gt;//VelocityContext键值对中的值  &lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;ArrayList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;getNames&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;  
    &lt;span class="nx"&gt;ArrayList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;ArrayList&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
    &lt;span class="nx"&gt;list.add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;element 1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="nx"&gt;list.add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;element 2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="nx"&gt;list.add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;element 3&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="nx"&gt;list.add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;element 4&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这个例子中，以健值对的形式将getNames()函数的返回值存放在Velocity容器中，并给其一个键值为&lt;code&gt;list&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;模板文件的代码如下&lt;code&gt;test.vm&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;##声明了一个变量  &lt;/span&gt;
&lt;span class="cp"&gt;#set( $this = &amp;quot;ppTest&amp;quot;)  &lt;/span&gt;
&lt;span class="cp"&gt;##将变量打印出来  &lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;great&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;  
&lt;span class="cp"&gt;##对后台的list进行扫描，将集合中的元素一个一个的打印出来  &lt;/span&gt;
&lt;span class="cp"&gt;#foreach( $name in $list )  &lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;showed&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;  
&lt;span class="cp"&gt;#end  &lt;/span&gt;
&lt;span class="cp"&gt;##设置一个判断条件，将将判断条件赋值为真  &lt;/span&gt;
&lt;span class="cp"&gt;#set( $condition = true)  &lt;/span&gt;
&lt;span class="cp"&gt;##判断条件为真，执行  &lt;/span&gt;
&lt;span class="cp"&gt;#if ($condition)  &lt;/span&gt;
&lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;  
&lt;span class="cp"&gt;##判断条件为假时，执行  &lt;/span&gt;
&lt;span class="cp"&gt;#else  &lt;/span&gt;
&lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;  
&lt;span class="cp"&gt;#end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其中的##表示的是注释&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#&lt;/code&gt;set类表示的是预处理指令&lt;/p&gt;
&lt;p&gt;$变量名表示声明的是一个变量&lt;/p&gt;
&lt;p&gt;上面的代码注释的已经很清楚了，如果只是应用，不需要了解更多细节的话，上面的代码已经够了，从上面的代码中可以看出&lt;code&gt;Velocity&lt;/code&gt;的一个好处就是模板文件与后台文件可以同步开发，只要约定好一些共有的变量定义即可，在模板输出时，由模板引擎进行变量的替换,替换之后再进行相应的输出&lt;/p&gt;
&lt;p&gt;第二个例子：&lt;code&gt;Velocity&lt;/code&gt;动态创建模板并渲染(Java工程)&lt;/p&gt;
&lt;p&gt;例子二，演示了在Java工程将模板渲染后以指定的编码方式&lt;code&gt;GBK&lt;/code&gt;输出，同时也演示了动态创建模板，然后进行渲染&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  
    &lt;span class="c1"&gt;//初始化Velocity引擎  &lt;/span&gt;
    &lt;span class="n"&gt;Velocity&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
    &lt;span class="c1"&gt;//获取一个VelocityContext对象  &lt;/span&gt;
    &lt;span class="n"&gt;VelocityContext&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;VelocityContext&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
    &lt;span class="c1"&gt;//向此对象容器中加入相应的键值对  &lt;/span&gt;
    &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Velocity&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;project&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Jakarta&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="c1"&gt;//StringWriter底层其实就是一个StringBuffer  &lt;/span&gt;
    &lt;span class="n"&gt;StringWriter&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StringWriter&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
    &lt;span class="c1"&gt;//将test2.vm与context进行合并，生成的最终代码写入StringWriter的buf中  &lt;/span&gt;
    &lt;span class="n"&gt;Velocity&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mergeTemplate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;test2.vm&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;GBK&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="c1"&gt;//将其在控制台上打印出来  &lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;模板:&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="c1"&gt;//动态创建模板  &lt;/span&gt;
    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;正在使用 $project $name 渲染模板&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StringWriter&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
    &lt;span class="cm"&gt;/* &lt;/span&gt;
&lt;span class="cm"&gt;     *context：对输入的字符串进行渲染 &lt;/span&gt;
&lt;span class="cm"&gt;     *w:渲染后的结果输出的地方 &lt;/span&gt;
&lt;span class="cm"&gt;     *mystring:发生错误时，被用来作为错误文件的名字 &lt;/span&gt;
&lt;span class="cm"&gt;     *s:包括VTL语言的输入字符串 &lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;   
    &lt;span class="n"&gt;Velocity&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;mystring&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
    &lt;span class="c1"&gt;//将结果进行输出来  &lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;例子二的模板文件&lt;code&gt;test2.vm&lt;/code&gt;如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Hello&lt;/span&gt; &lt;span class="err"&gt;来自于&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="err"&gt;在&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;project&lt;/span&gt; &lt;span class="err"&gt;工程里&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;例子二与例子一极为相似，例子二的模板只不过是在代码中创建的，例子一中的模板是直接引用外部的test.vm文件，从上面的代码中可以揣测一下Velocity是如何工作的，大概是这样的&lt;/p&gt;
&lt;p&gt;1、将外部的vm文件读入内存&lt;/p&gt;
&lt;p&gt;2、Velocity模板引擎对vm文件进行解析&lt;/p&gt;
&lt;p&gt;3、解析之后对模板文件中的变量进行替换，并执行vm中的相应判断逻辑&lt;/p&gt;
&lt;p&gt;4、执行完后，整个页面的渲染结果就知道了，再直接输出即可&lt;/p&gt;
&lt;p&gt;从这里可以看出只要前后台代码的开发人员能够约定相同的变量，则前后台的开发完全可以并行执行&lt;/p&gt;</summary><category term="淘宝技术"></category></entry><entry><title>Linux系统中并发与竞争机制分析</title><link href="http://www.yanyulin.info/pages/2014/03/concurrent.html" rel="alternate"></link><updated>2014-03-07T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2014-03-07:pages/2014/03/concurrent.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;现代&lt;code&gt;Linux&lt;/code&gt;系统中有相非常多的并发源，导致的问题就是并发与竞争，多个并发源竞争同一个共享数据
竞争的情况来自对资源的共享存取结果，当多个线程操作同一数据结构时，混乱就可能存在，在驱动编程中尽量避免共享资源，采用的方法通常是加锁机制。&lt;/p&gt;
&lt;p&gt;共享资源的互斥&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PV&lt;/code&gt;操作：PV操作实际上是对一个整形值进行操作，一个想进入临界区获取共享资源的进程调用P操作，如果整形值大于0,将整形值减1，获取共享资源，否则等待，使用完后调用V操作，将整形值增1，唤醒等待的进程&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt;下PV实现：&lt;/p&gt;
&lt;p&gt;要使用PV操作，必须包含&lt;code&gt;&amp;lt;linux/semaphore.h&amp;gt;,&lt;/code&gt;相关的数据类型是&lt;code&gt;struct semaphore&lt;/code&gt;,PV操作要进行创建然后初始化&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;sema_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;semaphore&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sem&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;//val是pv操作的初始整形值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;PV操作一般用于互斥，因此内核提供了如下的宏定义进行申明&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#define DECLARE_MUTEX(name)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果PV操作必须在运行时初始化，内核提供了如下操作&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#define init_MUTEX(sem)     sema_init(sem, 1)&lt;/span&gt;
&lt;span class="c"&gt;#define init_MUTEX_LOCKED(sem)  sema_init(sem, 0)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Linux中P操作对应如下三个函数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;down&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;semaphore&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sem&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//P操作递减整形值，如果没有，等待&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;__must_check&lt;/span&gt; &lt;span class="nf"&gt;down_interruptible&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;semaphore&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sem&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//P操作递减整形值，允许&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用户可中断&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;__must_check&lt;/span&gt; &lt;span class="nf"&gt;down_trylock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;semaphore&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sem&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//P操作不成功，立刻返回，不等待&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;V操作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;up&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;semaphore&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sem&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//信号使用完毕之后必须要返还给系统&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;读者写者的PV操作&lt;/p&gt;
&lt;p&gt;Linux内核为这种情况提供了一个特殊的类型rwsem(在linux/rwsem.h中)，rwsem必须在运行时显示的初始化&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Void&lt;/span&gt; &lt;span class="n"&gt;init_rwsem&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;rw_semaphore&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sem&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Completion机制&lt;/p&gt;
&lt;p&gt;Completion是任务使用的一个轻量级机制，允许一个线程告诉另一个线程工作已完成，为使用completion你的代码必须包括&lt;code&gt;&amp;lt;linux/completion.h&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;DECLARE_COMPLETION(name)创建completion&lt;/p&gt;
&lt;p&gt;自旋锁简介&lt;linux/spinlock.h&gt;类型为spinlock_t,同任何其他类型一样，自旋锁必须要初始化，注意所有的自旋锁都是不可中断的，一旦你调用 spin_lock你将自旋直到锁变为可用。&lt;/p&gt;
&lt;p&gt;对自旋锁进行操作的相关函数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#define spin_lock_irq(lock)     _spin_lock_irq(lock)&lt;/span&gt;
&lt;span class="c"&gt;#define spin_lock_bh(lock)      _spin_lock_bh(lock)//获得锁之前禁止软件中断&lt;/span&gt;
&lt;span class="c"&gt;#define spin_lock_irqsave(lock, flags)  //获得锁之间禁止中断，之前的中断保存在flag里   &lt;/span&gt;
&lt;span class="c"&gt;#define spin_trylock(lock)  &lt;/span&gt;
&lt;span class="c"&gt;#define spin_lock(lock)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有四个方法来释放自旋锁&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# define spin_unlock(lock)      _spin_unlock(lock)&lt;/span&gt;
&lt;span class="c"&gt;# define read_unlock(lock)      _read_unlock(lock)&lt;/span&gt;
&lt;span class="c"&gt;# define write_unlock(lock)     _write_unlock(lock)&lt;/span&gt;
&lt;span class="c"&gt;# define spin_unlock_irq(lock)      _spin_unlock_irq(lock)&lt;/span&gt;
&lt;span class="c"&gt;# define read_unlock_irq(lock)      _read_unlock_irq(lock)&lt;/span&gt;
&lt;span class="c"&gt;# define write_unlock_irq(lock)     _write_unlock_irq(lock)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;非阻塞的自旋锁操作&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Int&lt;/span&gt; &lt;span class="n"&gt;spin_trylock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;spinlock_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Int&lt;/span&gt; &lt;span class="n"&gt;spin_trylock_bh&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;spinlock_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这些函数成功时返回非零，否则0，没有try版本来禁止中断&lt;/p&gt;
&lt;p&gt;一个完整的加锁体制对于一个简单的整数值有点过分，对于这样的情况，内核提供了一个原子整数类型称为atomic_t定义在,&lt;code&gt;&amp;lt;asm/atomic.h&amp;gt;&lt;/code&gt;中&lt;/p&gt;</summary><category term="Linux汇总"></category></entry><entry><title>github搭建网站优化(修复过多的302重定向请求)</title><link href="http://www.yanyulin.info/pages/2014/03/github_site.html" rel="alternate"></link><updated>2014-03-05T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2014-03-05:pages/2014/03/github_site.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;本博客采用&lt;strong&gt;pelican&lt;/strong&gt;搭建，服务器采用的是免费的&lt;strong&gt;github&lt;/strong&gt;,博客搭建完成后，需要在博客根目录下写上一个配置文件&lt;code&gt;CNAME&lt;/code&gt;,其中&lt;code&gt;CNAME&lt;/code&gt;写上自已的域名，然后在DNS域名解析器里写上三条A记录，等上24个小时，即可在全球任何地点访问自已的网站，本网站的DNS采用的是免费的&lt;a href="https://www.dnspod.cn" target="_blank"&gt;DNSpod&lt;/a&gt;进行解析，在DNSPod里的配置如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;主机记录&lt;/span&gt;       &lt;span class="err"&gt;记录类型&lt;/span&gt;    &lt;span class="err"&gt;线路类型&lt;/span&gt;    &lt;span class="err"&gt;记录值&lt;/span&gt;        &lt;span class="n"&gt;MX&lt;/span&gt;&lt;span class="err"&gt;优先级&lt;/span&gt;    &lt;span class="n"&gt;TTL&lt;/span&gt;      
  &lt;span class="n"&gt;www&lt;/span&gt;         &lt;span class="n"&gt;A&lt;/span&gt;          &lt;span class="err"&gt;默认&lt;/span&gt;  &lt;span class="mf"&gt;207.97.227.245&lt;/span&gt;     &lt;span class="o"&gt;-&lt;/span&gt;         &lt;span class="mi"&gt;600&lt;/span&gt;
    &lt;span class="err"&gt;@&lt;/span&gt;         &lt;span class="n"&gt;A&lt;/span&gt;          &lt;span class="err"&gt;默认&lt;/span&gt;  &lt;span class="mf"&gt;207.97.227.245&lt;/span&gt;     &lt;span class="o"&gt;-&lt;/span&gt;         &lt;span class="mi"&gt;600&lt;/span&gt;
    &lt;span class="o"&gt;*&lt;/span&gt;         &lt;span class="n"&gt;A&lt;/span&gt;          &lt;span class="err"&gt;默认&lt;/span&gt;  &lt;span class="mf"&gt;207.97.227.245&lt;/span&gt;     &lt;span class="o"&gt;-&lt;/span&gt;         &lt;span class="mi"&gt;600&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;经过了上述的设置之后，的确可以正常访问网站，但是如果你用百度或者谷歌对网站的速度进行诊断，会发现有非常多的302重定向请求&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是302重定向请求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;假设浏览器要访问服务器的a.html页面，服务器上没有a.html页面，在服务器上将所有对a.html页面的访问全部转向了访问 b.html,那么当用户访问a.html页面时，服务器就会产生一个应答，应答的类型就是302类型，同时应答消息里还会含有b.html的位置，浏览器在接收到302类型的消息后，会取出应答消息中的url重新发送一次请求，请求b.html&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;从上述过程的分析中，可以看出一次重定向，会发生两次请求，因些耗费了非常多的时间，当网站中有太多的重定向请求时，势必会影响网站的响应速度&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;github上搭建的博客，如何按照上述的DNS设置之后，网站由于产生了过多的重定向，会大大影响网站的响应速度，以下是采用上述设置之后，百度诊断网速的结果示意图，是不是很不理想，这样的响应速度不仅影响了用户体验，而且还会影响各大搜索引擎的收录&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;a href="http://www.yanyulin.info/pages/2014/03/github_site.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/github_site0.jpg"  alt="烟雨林博客" /&gt;
&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;修改DNS域名解析器，此处即为DNSPod,在DNSPod里停用A记录，采用别名，即CNAME,将CNAME指向主机的域名即可，即指向&lt;code&gt;username.github.io&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;主机记录&lt;/span&gt;       &lt;span class="err"&gt;记录类型&lt;/span&gt;    &lt;span class="err"&gt;线路类型&lt;/span&gt;      &lt;span class="err"&gt;记录值&lt;/span&gt;        &lt;span class="n"&gt;MX&lt;/span&gt;&lt;span class="err"&gt;优先级&lt;/span&gt;       &lt;span class="n"&gt;TTL&lt;/span&gt;     
  &lt;span class="n"&gt;www&lt;/span&gt;       &lt;span class="n"&gt;CNAME&lt;/span&gt;        &lt;span class="err"&gt;默认&lt;/span&gt;   &lt;span class="n"&gt;username&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;github&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;     &lt;span class="o"&gt;-&lt;/span&gt;         &lt;span class="mi"&gt;600&lt;/span&gt;
    &lt;span class="err"&gt;@&lt;/span&gt;       &lt;span class="n"&gt;CNAME&lt;/span&gt;        &lt;span class="err"&gt;默认&lt;/span&gt;   &lt;span class="n"&gt;username&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;github&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;     &lt;span class="o"&gt;-&lt;/span&gt;         &lt;span class="mi"&gt;600&lt;/span&gt;
    &lt;span class="o"&gt;*&lt;/span&gt;       &lt;span class="n"&gt;CNAME&lt;/span&gt;        &lt;span class="err"&gt;默认&lt;/span&gt;   &lt;span class="n"&gt;username&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;github&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;     &lt;span class="o"&gt;-&lt;/span&gt;         &lt;span class="mi"&gt;600&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;等一会，短点的话大概几分钟左右，长点估计行24小时，因为DNS也要将更改的域名广播出去~~~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;测试，采用百度网速度诊断测试，测试后的结果如下图所示，网站的速度还行吧~~~&lt;/p&gt;
&lt;p&gt;网站评分结果：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;a href="http://www.yanyulin.info/pages/2014/03/github_site.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/github_site1.jpg"  alt="烟雨林博客"/&gt;
&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;网站重定向结果：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;a href="http://www.yanyulin.info/pages/2014/03/github_site.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/github_site2.jpg"  alt="烟雨林博客"/&gt;
&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pelican搭建博客教程如下&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2013/11/pelican.html" target="_blank"&gt;
http://www.yanyulin.info/pages/2013/11/pelican.html&lt;/a&gt;&lt;/p&gt;</summary><category term="工具使用"></category></entry><entry><title>git保存用户名与密码(避免用户名密码输入)</title><link href="http://www.yanyulin.info/pages/2014/03/git.html" rel="alternate"></link><updated>2014-03-04T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2014-03-04:pages/2014/03/git.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;写在前面的话&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于本博客是托管于github之上，因此每次&lt;code&gt;git push -u origin master&lt;/code&gt;时都得输入用户名与密码，是非常烦人的，经过一番尝试，原来可以写一个配置文件避免输入用户名与密码，这样通过git上传文件到github上就非常方便了~~~&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git&lt;/code&gt;工具是由linux之父开发的一款分布式代码管理工具，代码开源，功能强大，&lt;code&gt;git&lt;/code&gt;开发的一般流程是首先从服务器上&lt;code&gt;clone&lt;/code&gt;一份主干代码，相当于创建了分支，然后修改分支代码，最后将修改后的代码提交到服务器上，为了安全，每一提交都需要输入用户名与密码，肯定是很繁琐的，因此得想办法，避免每次提交时都需要输入&lt;strong&gt;用户名与密码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、设置环境变量，在我的电脑上单击右键-&amp;gt;属性-&amp;gt;高级-&amp;gt;环境变量-&amp;gt;系统变量-&amp;gt;新建里写上如下代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;变量名：&lt;/span&gt;&lt;span class="n"&gt;HOME&lt;/span&gt;
&lt;span class="err"&gt;变量值&lt;/span&gt;&lt;span class="o"&gt;:%&lt;/span&gt;&lt;span class="n"&gt;HOMEPATH&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果使用的是Win7系统可以直接输入以下命令:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;setx&lt;/span&gt; &lt;span class="n"&gt;HOME&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;USERPROFILE&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以下是WinXP下的截图：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;a href="http://www.yanyulin.info/pages/2014/03/git.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/git0.jpg"  alt="烟雨林博客"/&gt;
&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;2、在运行窗口（可以按Windows+R键）中输入如下命令，即可以打开%HOMEPATH%文件夹，在该文件夹下建立一个文件，文件名为&lt;code&gt;_netrc&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;a href="http://www.yanyulin.info/pages/2014/03/git.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/git1.jpg"  alt="烟雨林博客"/&gt;
&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;命令如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;%HOMEPATH%&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3、以记事本的形貌打开_netrc文件，在文件里面输入如下配置项：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;machine&lt;/span&gt; &lt;span class="n"&gt;github&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;
&lt;span class="n"&gt;login&lt;/span&gt; &lt;span class="o"&gt;*****&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;gmail&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;
&lt;span class="n"&gt;password&lt;/span&gt; &lt;span class="o"&gt;******&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码中&lt;/p&gt;
&lt;p&gt;machine：表示要上传的服务器，上述代码中表示要上专到github.com中&lt;/p&gt;
&lt;p&gt;login：填入登录用户名，例子中应该填入github帐户名&lt;/p&gt;
&lt;p&gt;password：填入登录密码，例子中应该填入github帐户密码&lt;/p&gt;
&lt;p&gt;如有问题，可以联系我，联系方式，看博客下方邮箱&lt;/p&gt;</summary><category term="工具使用"></category></entry><entry><title>pelican博客搭建设置分页和分页保存位置</title><link href="http://www.yanyulin.info/pages/2014/03/pelican_page.html" rel="alternate"></link><updated>2014-03-04T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2014-03-04:pages/2014/03/pelican_page.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;本篇&lt;strong&gt;博客&lt;/strong&gt;紧随前几篇博客而来&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2013/11/pelican.html" target="_blank" &gt;pelican搭建属于自已的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2014/01/pelican_question.html" target="_blank" &gt;pelican创建博客常见问题汇总&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2014/03/comment.html" target="_blank" &gt;博客添加第三方评论系统多说评论框&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2014/03/navigator.html" target="_blank" &gt;pelican创建博客如何设置导航条&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天介绍一下pelican创建博客中如何进行博客的分页，分页效果可以参考本博客首页底部效果图，该效果图类似于百度搜索的分页机制，一次性不会显示出全部分页，会随用户的选择的分页显示出该分页前几分页以及后几分页，话不多说，截图如下：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;a href="http://www.yanyulin.info/pages/2014/03/pelican_page.html"&gt;
&lt;img  alt="烟雨林博客"  src="http://www.yanyulin.info/pics/tools/pelican_page0.jpg"/&gt;
&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;pelican创建上述分页机制的步骤如下：&lt;/p&gt;
&lt;p&gt;1、更改配置文件pelicanconf.py，加入如下配置选项：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;DEFAULT_PAGINATION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;
&lt;span class="n"&gt;PAGINATION_PATTERNS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;}.&lt;/span&gt;&lt;span class="n"&gt;html&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;base_name&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;page&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;}{&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;}.&lt;/span&gt;&lt;span class="n"&gt;html&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;配置选项的含义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DEFAULT_PAGINATION = 11表示分页时一页显示11条&lt;/p&gt;
&lt;p&gt;PAGINATION_PATTERNS里面配置的是分页时各分布保存的位置，上述代码的含义就是第1分页保存在网站根目录下，从第二分页开始，保存在page目录下&lt;/p&gt;
&lt;p&gt;2、Pelican采用的是&lt;code&gt;JinJa2&lt;/code&gt;模板，最好先了解一下&lt;code&gt;JinJa2&lt;/code&gt;,本博客中分页长度是11个长度，也就是上图中的分页小方块最多有11个，当分页数&lt;code&gt;&amp;gt;11&lt;/code&gt;时，假设为12时，当用户点击第10页时，则会显示&lt;code&gt;2-12&lt;/code&gt;页，当用户点击第1页时，则又会显示&lt;code&gt;1-11&lt;/code&gt;页，实现代码如下(代码更改在模板中的pagination.html中)：&lt;/p&gt;
&lt;p&gt;&lt;textarea style="width:100%;height:450px" &gt;
    {% if DEFAULT_PAGINATION %}
        {% set pageCut=11 %}
        {% set cut=5 %}
        &lt;div class="navigation_b"&gt;
            &lt;div class="pagination"&gt;      &lt;br /&gt;
                {% set currentpage=articles_page.number %}
                {% if currentpage-cut &amp;gt;0 and articles_paginator.num_pages-currentpage &amp;gt;= cut %}
                    {% for j in range(currentpage-cut,currentpage) %} 
                        {% if j ==currentpage %}
                           &lt;span class="current"&gt;{{articles_page.number}}&lt;/span&gt;
                        {% elif j ==1 %}
                           &lt;a href="{{ SITEURL }}/{{ page_name }}.html" class="inactive"&gt;{{ j }}&lt;/a&gt;      &lt;br /&gt;
                        {% else %}
                           &lt;a href="{{ SITEURL }}/page/{{ page_name }}{{ j }}.html" class="inactive"&gt;
                            {{ j }}
                           &lt;/a&gt;
                           {% endif %}
                       {% endfor %}
                       {% for j in range(currentpage,currentpage+cut+1) %} 
                           {% if j ==currentpage %}
                             &lt;span class="current"&gt;{{articles_page.number}}&lt;/span&gt;
                           {% else %}
                              &lt;a href="{{ SITEURL }}/page/{{ page_name }}{{ j }}.html" class="inactive"&gt;
                              {{ j }}
                              &lt;/a&gt;
                           {% endif %}
                        {% endfor %}
                 {% elif articles_paginator.num_pages &amp;gt; pageCut and articles_paginator.num_pages-currentpage&lt;pageCut %}
                       {% for j in range(pageCut-1,-1,-1) %} 
                            {% if articles_paginator.num_pages-j==currentpage %}
                              &lt;span class="current"&gt;{{articles_page.number}}&lt;/span&gt;
                            {% elif articles_paginator.num_pages-j ==1 %}         &lt;br /&gt;
                                &lt;a href="{{ SITEURL }}/page/{{ page_name }{{ j }}.html" class="inactive"&gt;
                                {{ j }}
                                &lt;/a&gt;
                            {% else %}
                                &lt;a href="{{ SITEURL }}/page/{{ page_name }}{{ articles_paginator.num_pages-j }}.html" class="inactive"&gt;
                                    {{ articles_paginator.num_pages-j }}
                                &lt;/a&gt;
                            {% endif %}
                        {% endfor %}  &lt;br /&gt;
                  {% else %}
                            {% if articles_paginator.num_pages &amp;lt; pageCut %}
                                {% set realPage=articles_paginator.num_pages %}
                            {% else %}
                                {% set realPage=pageCut %}
                            {% endif %}
                            {% for j in range(1,realPage+1) %} 
                                {% if j ==currentpage %}
                              &lt;span class="current"&gt;{{articles_page.number}}&lt;/span&gt;
                                {% elif j ==1 %}
                                &lt;a href="{{ SITEURL }}/{{ page_name }}.html" class="inactive"&gt;
                                    {{ j }}
                                &lt;/a&gt;
                                {% else %}
                                  {% if j ==currentpage %}
                                   &lt;span class="current"&gt;{{articles_page.number}}&lt;/span&gt;
                                  {% else %}
                                    &lt;a href="{{ SITEURL }}/page/{{ page_name }}{{ j }}.html" class="inactive"&gt;
                                        {{ j }}
                                    &lt;/a&gt;
                                  {% endif %}
                                {% endif %}
                            {% endfor %}                                  &lt;br /&gt;
                        {% endif %}
            &lt;a href="{{ SITEURL }}/{{ page_name }}.html"&gt;首页&lt;/a&gt;
            {% if articles_paginator.num_pages == 1 %}
                    &lt;a href="{{ SITEURL }}/{{ page_name }}.html"&gt;
                        尾页
                    &lt;/a&gt;&lt;/div&gt;
            {% else %}
                    &lt;a href="{{ SITEURL }}/page/{{ page_name }}{{articles_paginator.num_pages}}.html"&gt;
                        尾页
                    &lt;/a&gt;&lt;/div&gt;
            {% endif %}
    &lt;/div&gt;
    {% endif %}
&lt;/textarea&gt;&lt;/p&gt;
&lt;p&gt;上述的代码看起来比较长，去掉CSS样式后可以直接使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;备注，程序注解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、&lt;code&gt;{% if DEFAULT_PAGINATION %}&lt;/code&gt;表示的是如果设置了分布时，则执行后绪代码&lt;/p&gt;
&lt;p&gt;2、&lt;code&gt;{% set pageCut=11 %}&lt;/code&gt;设置一变量，代表的是每页显示的条目数&lt;/p&gt;
&lt;p&gt;3、&lt;code&gt;{% set cut=5 %}&lt;/code&gt;表示的是以用户当前点击的分页为坐标，该分页前后应该都显示&lt;code&gt;5页&lt;/code&gt;(如果当前页前面或者后面分页数不足五页要在程序中进行处理)&lt;/p&gt;
&lt;p&gt;4、&lt;code&gt;articles_page.number&lt;/code&gt;代表的是当前所处的分页&lt;/p&gt;
&lt;p&gt;5、&lt;code&gt;articles_paginator.num_pages&lt;/code&gt;代表的是总共的分页数目&lt;/p&gt;
&lt;p&gt;6、&lt;code&gt;{{ SITEURL }}&lt;/code&gt;代表的是网站域名，在配置文件中可以查到，此处就是&lt;a href="www.yanyulin.info"  target="_blank"&gt;http://www.yanyulin.info&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7、&lt;code&gt;{{ page_name }}&lt;/code&gt;代表的是分页名，其中分页名还含有分页所在的目录，即假如分页pelican.html在page目录下的category目录中，则分页名实际上为&lt;strong&gt;category/pelican&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如有问题，可以联系我，联系方式，看博客下方邮箱&lt;/strong&gt;&lt;/p&gt;</summary><category term="工具使用"></category></entry><entry><title>pelican创建博客如何设置导航条</title><link href="http://www.yanyulin.info/pages/2014/03/navigator.html" rel="alternate"></link><updated>2014-03-03T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2014-03-03:pages/2014/03/navigator.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;Pelican搭建博客中，如果比较懒，可以直接使用官方提供的主题，官方提供的主题均比较简单，做一些简单的博客还是可以的，但要想做到美观、大方似乎还得努力，今天分享一下，&lt;strong&gt;本博客&lt;/strong&gt;(当然也是采用pelican搭建的)在搭建过程中，如何使用pelican创建自定义的菜单，菜单的样式如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;a href="http://www.yanyulin.info/pages/2014/03/navigator.html"&gt;
&lt;img  alt="烟雨林博客" src="http://www.yanyulin.info/pics/tools/nav1.jpg"/&gt;
&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;本博客的搭建过程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2013/11/pelican.html" target="_blank"&gt;
pelican搭建属于自已的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2013/11/github.html" target="_blank"&gt;
Github简明教程(入门篇)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2013/11/githubM.html" target="_blank"&gt;
Github上如何给别人贡献代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2014/01/pelican_question.html" target="_blank"&gt;
pelican创建博客常见问题汇总
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2014/03/comment.html" target="_blank"&gt;
博客添加第三方评论系统多说评论框
&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Pelican是基于Jinja2模板的，因此在设置菜单时有必要了解一些JinJa2的语法以及相关函数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;菜单设置步骤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、配置文件&lt;code&gt;pelicanconf.py&lt;/code&gt;的设置&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;DISPLAY_PAGES_ON_MENU&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;False&lt;/span&gt;
&lt;span class="n"&gt;DISPLAY_CATEGORIES_ON_MENU&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DISPLAY_PAGES_ON_MENU = False&lt;/code&gt;表示的是单独页即&lt;code&gt;page&lt;/code&gt;文件夹里的标题不显示在导航菜单中&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DISPLAY_CATEGORIES_ON_MENU = False&lt;/code&gt;表示的是目录,即文章分类要显示在导航菜单中&lt;/p&gt;
&lt;p&gt;2、在目录中，有些目录不想显示在导航条中，如本博文中的&lt;a href="http://www.yanyulin.info/category/cheng-xu-yuan-zhao-gong-zuo.html" target="_blank"&gt;程序员找工作&lt;/a&gt;以及&lt;a href="http://www.yanyulin.info/category/cheng-xu-yuan-de-mian-jing.html" target="_blank"&gt;程序员的面经&lt;/a&gt;可以在配置文件中写上如下语句，表示不想显示的目录：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;LINKS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;程序员找工作&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;程序员的面经&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;&lt;span class="err"&gt;#&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3、设置好上述的配置文件后，打开你自已的主题，例如本博文的主题是&lt;code&gt;pelican-themes/gum&lt;/code&gt;,找到templates文件夹下的base.html，写下如下代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;&amp;lt;!--表示的是如果是首页时，对样式进行的设置，效果如本博文稿www.yanyulin.info主页导航栏--&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;page_name&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;index&amp;quot;&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;                       
&lt;span class="nt"&gt;&amp;lt;li&lt;/span&gt;  &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;current-menu-item current_page_item &amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;a&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;SITEURL&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;烟雨首页&lt;span class="nt"&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;SITEURL&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;烟雨首页&lt;span class="nt"&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;endif&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;span class="c"&gt;&amp;lt;!--看看菜单栏里是否有菜单--&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;title&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;link&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nv"&gt;MENUITEMS&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;li&lt;/span&gt; &lt;span class="nt"&gt;&amp;gt;&amp;lt;a&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;link&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;title&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;endfor&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;span class="c"&gt;&amp;lt;!--看看page目录下的页标题是否显示--&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;DISPLAY_PAGES_ON_MENU&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;p&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nv"&gt;PAGES&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;SITEURL&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="s"&gt;/&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;p.url&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;p.title&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;endfor&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;span class="c"&gt;&amp;lt;!--关键部件，即显示目录名字到导航条上--&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;DISPLAY_CATEGORIES_ON_MENU&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;span class="c"&gt;&amp;lt;!--过滤掉不想显示的目录--&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;dit&lt;/span&gt;&lt;span class="o"&gt;=[]&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;txm&lt;/span&gt; &lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nv"&gt;null&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nv"&gt;LINKS&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;dit.append&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;txm&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;endif&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;endfor&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;span class="c"&gt;&amp;lt;!--开如显示--&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;cat&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;null&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nv"&gt;categories&lt;/span&gt;  &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;cat&lt;/span&gt; &lt;span class="k"&gt;not&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nv"&gt;dit&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;category&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nv"&gt;cat&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;                                                
&lt;span class="nt"&gt;&amp;lt;li&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;current-menu-item current_page_item &amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;a&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;SITEURL&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="s"&gt;/&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;cat.url&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;cat&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;li&amp;gt;&amp;lt;a&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;SITEURL&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="s"&gt;/&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;cat.url&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;cat&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;endif&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt;&lt;span class="k"&gt;endif&lt;/span&gt;&lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;endfor&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;endif&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;endif&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;多看上面注释，代码不难理解&lt;/p&gt;
&lt;p&gt;4、更改了上述主题后，将原有主题卸载，重新安装，如下是以本博文主题&lt;code&gt;gum&lt;/code&gt;为例子，代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;pelican&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;themes&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="n"&gt;gum&lt;/span&gt;

&lt;span class="n"&gt;pelican&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;themes&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;pelican&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;themes&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;gum&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如有问题，可以联系我，联系方式，看博客下方邮箱&lt;/p&gt;</summary><category term="工具使用"></category></entry><entry><title>博客添加第三方评论系统多说评论框</title><link href="http://www.yanyulin.info/pages/2014/03/comment.html" rel="alternate"></link><updated>2014-03-02T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2014-03-02:pages/2014/03/comment.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;&lt;code&gt;博客&lt;/code&gt;已经基本搭建完成，前前后后历时将近两周，采用的是开源工具&lt;code&gt;Pelican&lt;/code&gt;搭建，服务器采用的是强大的分布式代码托管库&lt;code&gt;Github&lt;/code&gt;,两者的教程可以参考下面的链接，本博客总共破费了&lt;code&gt;我3美元&lt;/code&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2013/11/pelican.html" target="_blank"&gt;
pelican搭建属于自已的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2013/11/github.html" target="_blank"&gt;
Github简明教程(入门篇)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2013/11/githubM.html" target="_blank"&gt;
Github上如何给别人贡献代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2014/01/pelican_question.html" target="_blank"&gt;
pelican创建博客常见问题汇总
&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天&lt;code&gt;分享&lt;/code&gt;一下，博客如何添加&lt;strong&gt;第三方评论系统&lt;/strong&gt;，国外的第三方评论系统已经做的相当强大，如&lt;code&gt;disqus&lt;/code&gt;,但国外终究是国外，与国内行情不同，如&lt;code&gt;disqus&lt;/code&gt;不支持&lt;strong&gt;微博、QQ、人人、百度贴吧&lt;/strong&gt;登录以及分享等，国内的第三方评论系统起步较国外晚，但做的也相当不错，如&lt;strong&gt;多说、友言、评论啦&lt;/strong&gt;等，比较符合国内的行情，本博客最初搭建时采用的第三方评论系统为&lt;code&gt;disqus&lt;/code&gt;,最后发现&lt;code&gt;disqus&lt;/code&gt;除了上述的缺点之外，还有一个非常严重的问题，就是在&lt;code&gt;IE7/IE6&lt;/code&gt;下，&lt;code&gt;disqus&lt;/code&gt;会出现问题，即不能很好的跨浏览器，使用了将近两周，于是弃之，改用了国内的多说&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么采用第三方评论系统&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.数据库以及空间贵，我等屌丝还支付不起&lt;/p&gt;
&lt;p&gt;2.第三方评论系统具有强大的反垃圾机制，可以有效的过滤垃圾流言&lt;/p&gt;
&lt;p&gt;3.添加容易，界面操作方便，省去了我们自已写代码&lt;/p&gt;
&lt;p&gt;4.功能比较强大，都带有自已的&lt;code&gt;分享按钮&lt;/code&gt;以及&lt;strong&gt;微博、QQ、人人、百度贴吧&lt;/strong&gt;登录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;多说评论框&lt;/strong&gt;*&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.支持国内目前主流的SNS,如&lt;strong&gt;微博、QQ、人人、百度贴吧&lt;/strong&gt;,国外嘛，也没必要，你懂的~&lt;/p&gt;
&lt;p&gt;2.团队技术实力还是比较强大&lt;/p&gt;
&lt;p&gt;3.&lt;code&gt;多说&lt;/code&gt;支持&lt;code&gt;SEO优化&lt;/code&gt;,这是其最为突出的地方，也最吸引人的...&lt;/p&gt;
&lt;p&gt;4.评论系统反馈比较及时，界面美观，提供自定义....&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;重点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.向博客中添加评论系统，首先要在多说网上注册自已的帐号，注册帐号后要验证自已的域名，邮箱等，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;a href="http://www.yanyulin.info/pages/2014/03/comment.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/duoshuo1.jpg"  alt="烟雨林博客"/&gt;
&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;2.点击管理员左侧的工具，获取通用代码，或者直接复制下面的代码，将该代码粘贴到博客中需要添加评论的地方，即可&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;&amp;lt;!-- Duoshuo Comment BEGIN --&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ds-thread&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
var duoshuoQuery = {short_name:&amp;quot;yanyulin&amp;quot;};
    (function() {
        var ds = document.createElement(&amp;#39;script&amp;#39;);
        ds.type = &amp;#39;text/javascript&amp;#39;;ds.async = true;
        ds.src = &amp;#39;http://static.duoshuo.com/embed.js&amp;#39;;
        ds.charset = &amp;#39;UTF-8&amp;#39;;
        (document.getElementsByTagName(&amp;#39;head&amp;#39;)&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; 
        || document.getElementsByTagName(&amp;#39;body&amp;#39;)&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;).appendChild(ds);
    })();
    &lt;span class="nt"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;&amp;lt;!-- Duoshuo Comment END --&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;代码中的的&lt;code&gt;short_name&lt;/code&gt;要改写成添加站点时&lt;code&gt;http://www.XXXX.duoshuo.com&lt;/code&gt;中的&lt;code&gt;XXXX&lt;/code&gt;部分，添加成功后，运行图我如下图如博文下面的评论框所示&lt;/p&gt;
&lt;p&gt;3.给博文添加最新评论，效果如我的博客右侧栏如示，代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;ul&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ds-recent-comments&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;data-num-items=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;7&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;data-show-title=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;0&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;data-show-avatars=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;data-show-time=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;1&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;data-show-admin=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;0&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;data-excerpt-length=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;40&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;clear&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;&amp;lt;!--多说js加载开始，一个页面只需要加载一次 --&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
var duoshuoQuery = {short_name:&amp;quot;yanyulin&amp;quot;};
(function() {
    var ds = document.createElement(&amp;#39;script&amp;#39;);
    ds.type = &amp;#39;text/javascript&amp;#39;;ds.async = true;
    ds.src = &amp;#39;http://static.duoshuo.com/embed.js&amp;#39;;
    ds.charset = &amp;#39;UTF-8&amp;#39;;
    (document.getElementsByTagName(&amp;#39;head&amp;#39;)&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; || document.getElementsByTagName(&amp;#39;body&amp;#39;)&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;).appendChild(ds);
})();
&lt;span class="nt"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;&amp;lt;!--多说js加载结束，一个页面只需要加载一次 --&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;代码中的的&lt;code&gt;short_name&lt;/code&gt;要改写成添加站点时&lt;code&gt;http://www.XXXX.duoshuo.com&lt;/code&gt;中的&lt;code&gt;XXXX&lt;/code&gt;部分&lt;/p&gt;
&lt;p&gt;最终的结果如下图所示&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;a href="http://www.yanyulin.info/pages/2014/03/comment.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/duoshuo2.jpg"  alt="烟雨林博客"/&gt;
&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;如有问题，可以联系我，联系方式，看博客下方邮箱&lt;/p&gt;</summary><category term="工具使用"></category></entry><entry><title>C++中类初始化列表的妙用</title><link href="http://www.yanyulin.info/pages/2014/02/classinitiallist.html" rel="alternate"></link><updated>2014-02-22T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2014-02-22:pages/2014/02/classinitiallist.html</id><summary type="html">&lt;p&gt;C++中类初始化列表的妙用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1：类的初始化列表是怎么提高效率的？&lt;/p&gt;
&lt;p&gt;2：类的初始化列表是按照列表中出现的顺序来初始化的吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看下面的两个程序代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nl"&gt;public:&lt;/span&gt;
        &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;construct A&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;destruct A&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nl"&gt;public:&lt;/span&gt;
        &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;程序二：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nl"&gt;public:&lt;/span&gt;
        &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;construct A&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;destruct A&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nl"&gt;public:&lt;/span&gt;
        &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;程序一被编译器实际转化为了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//以下代码不可实际运行，只是说明问题&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//调用A的构造函数&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="nf"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//产生一个临时的对象&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//通过赋值运算符将临时对象付给a&lt;/span&gt;
    &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::~&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//释放临时对象空间&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下面是相应的汇编代码：可以发现和上面的过程分析是一样的，有兴趣可以自已研究下
程序二在底层被转化成了&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;a href="http://www.yanyulin.info/pages/2014/02/classinitiallist.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/tech/classlist.png"/&gt;
&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;可以发现通过初始化列表在申请了对象a的空间后直接调用初始化列表中指定的构造函数来构造成员对象，因此少了很多中间步骤，因此提高了程序的效率:)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这是程序二对应的汇编代码(看看就知道了吧:))：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;dword&lt;/span&gt; &lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ebp&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;ecx&lt;/span&gt;
&lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;mov&lt;/span&gt; &lt;span class="n"&gt;ecx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;dword&lt;/span&gt; &lt;span class="n"&gt;ptr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;ebp&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;ILT&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0040100f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;到这了，初始化列表确实能够提高程序的效率，不是吗:)，初始化列表就是指明了应该调用成员对象的哪个构造函数对于第二个问题并不是按初始化列表来构造成员的，就不做实验了，有兴趣的可一块讨论，构造函数初始化的顺序是按这个顺序，先根据基类的声明顺序，调用基类的构造函数，初始化基类，再按照类里面成员对象的声明顺序调用成员对象的构造函数对成员对象进行初始化:)&lt;/p&gt;
&lt;p&gt;以下几种情况一定要用到初始化列表&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1:当初始化一个引用成员对象时&lt;/p&gt;
&lt;p&gt;2:当初始化一个const成员对象时(1、2两种情况可以想想为什么？原理是一样的，注意强调的是对象)&lt;/p&gt;
&lt;p&gt;3:当调用一个基类的构造函数，而它拥有一组带参数的构造函数时&lt;/p&gt;
&lt;p&gt;4:当类里面的成员对象有自已的构造函数时，且有参数时(3、4归为一类，为什么必须使用，原理也是一样的)&lt;/p&gt;
&lt;/blockquote&gt;</summary><category term="C++学习"></category></entry><entry><title>快速介绍Linux（Linux入门教程）</title><link href="http://www.yanyulin.info/pages/2014/02/linux1.html" rel="alternate"></link><updated>2014-02-22T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2014-02-22:pages/2014/02/linux1.html</id><summary type="html">&lt;p&gt;1：严格意义上，可将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境，我们称此种软件为内核，它相对较小，位于环境中心&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;a href="http://www.yanyulin.info/pages/2014/02/linux1.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/tech/linuxmen1.png" alt="烟雨林博客"/&gt;
&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;图一介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;内核的接口称为系统调用（阴影部分）&lt;/p&gt;
&lt;p&gt;公用函数库(如glibc【即C语言库】)是构建在系统调用之上&lt;/p&gt;
&lt;p&gt;Shell是一种特殊的程序，它为其他应用程序提供一个接口&lt;/p&gt;
&lt;p&gt;登录Linux&lt;/p&gt;
&lt;p&gt;登录Linux有两种方式，一种是文本模式登录，一种是图形界面登录&lt;/p&gt;
&lt;p&gt;文本模式登录【没有图形界面，类似于控制台】，在VirtulBox中进入了Linux后，按Ctrl+F1可以进入文本模式如下图&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;center&gt;
&lt;a href="http://www.yanyulin.info/pages/2014/02/linux1.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/tech/linuxmen2.png" alt="烟雨林博客"/&gt;
&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;输入用户名与密码即可登录成功结果如下&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;a href="http://www.yanyulin.info/pages/2014/02/linux1.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/tech/linuxmen3.png" alt="烟雨林博客"/&gt;
&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;图中用户名是pengpeng,登录成功后进入用户的家目录&lt;strong&gt;(所谓家目录即/home/pengpeng这个目录，Linux为系统的每个用户都在/home目录下创建了以用户名为名称的目录，作为用户登录成功后的当前目录)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图三中命令介绍：&lt;/p&gt;
&lt;p&gt;ls 列出当前目录所有文件，不包括隐藏文件&lt;/p&gt;
&lt;p&gt;cd改变目录，&lt;code&gt;cd /home/pengpeng&lt;/code&gt;【/home/pengpeng中/是根目录即根目录-&amp;gt;home目录-&amp;gt;pengpeng，采用的是绝对路径】【备注cd ~ 改变目录为当前家目录】&lt;/p&gt;
&lt;p&gt;图形界面登录略&lt;/p&gt;
&lt;p&gt;附:登录过程&lt;/p&gt;
&lt;p&gt;用户在登录Linux系统时，输入用户名与密码，系统会在其口令文件/etc/passwd中查看校验是否为合法用户，口令文件如下&lt;/p&gt;
&lt;p&gt;在终端上输入&lt;code&gt;vim /etc/passwd&lt;/code&gt;【vim/vi是linux中的一种文本编辑器，默认只安了vi,安装vim输入以下命令sudo su apt-get install vim】&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;a href="http://www.yanyulin.info/pages/2014/02/linux1.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/tech/linuxmen4.png" alt="烟雨林博客"/&gt;
&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;口令文件组成的意思如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;pengpeng&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;pengpeng&lt;/span&gt;&lt;span class="o"&gt;,,,:/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="sr"&gt;/pengpeng:/bin/&lt;/span&gt;&lt;span class="n"&gt;bash&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中pengpeng是用户名 x对应的是用户密码【加密了】1000用户ID,1000用户组ID,pengpeng,,,注释字段，/home/pengpeng用户登录后进入的目录【即当前目录为家目录】，/bin/bash登录后用户默认使用的shell即Bourne shell&lt;/p&gt;
&lt;p&gt;Shell&lt;/p&gt;
&lt;p&gt;Shell是一个命令行解释器，它读取用户的输入，然后执行命令，用户通常通过终端(类似于Windows中的cmd.exe)向shell进行输入，Shell有好多种，如Bourne shell, C shell, Korn Shell,等，我们现在使用的一般都是Bourne shell&lt;/p&gt;
&lt;p&gt;文件与目录&lt;/p&gt;
&lt;p&gt;Linux文件系统是目录与文件组成的一种层次结构，目录的起点称为根【名称为/】,每个目录中都包括了两个特殊的文件.与..这两个文件是链接文件，分别指向当前目录与上一级目录&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd .&lt;/code&gt;即转向当前目录【其实不变】 &lt;/p&gt;
&lt;p&gt;&lt;code&gt;cd ..&lt;/code&gt; 返回上一级目录&lt;/p&gt;
&lt;p&gt;Linux系统中以/开关的路径名是绝对路径名，否则为相对路径名&lt;/p&gt;
&lt;p&gt;实例分析：ls的简要现&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;a href="http://www.yanyulin.info/pages/2014/02/linux1.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/tech/linuxmen5.png" alt="烟雨林博客"/&gt;
&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;在终端上输入&lt;code&gt;vim lsM.c&lt;/code&gt;创建如上文件&lt;/p&gt;
&lt;p&gt;说明&lt;/p&gt;
&lt;p&gt;&lt;code&gt;drent.h&lt;/code&gt;中包括对目录进行的相关操作&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DIR&lt;/code&gt;是一个目录结构&lt;/p&gt;
&lt;p&gt;&lt;code&gt;struct dirent&lt;/code&gt;是一个结构体，包涵目录或者文件的相关属性&lt;/p&gt;
&lt;p&gt;编译&lt;code&gt;lsM.c&lt;/code&gt;生成可执行文件，并执行&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;a href="http://www.yanyulin.info/pages/2014/02/linux1.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/tech/linuxmen6.png" alt="烟雨林博客"/&gt;
&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Gcc&lt;/code&gt;是C语言编译器, -o选项表示后面是输入的目标文件的文件名 lsM.c表示编译的源程序&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ls&lt;/code&gt;命令输入后可以发现生成了可执行的lsM&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./lsM&lt;/code&gt; &lt;code&gt;.&lt;/code&gt;可以发现当前目录中包括四个文件&lt;/p&gt;
&lt;p&gt;注意：本程序的输出的文件未进行排序，而ls的输出一般是按照字母的顺序进行输出&lt;/p&gt;
&lt;p&gt;Main函数使用了ISO C标准使用的风格,argc代表传给程序的参数个数，即&lt;code&gt;argv&lt;/code&gt;中的个数&lt;/p&gt;
&lt;p&gt;按惯例当程序返回0时表示正常结束，返回其他值表求出错&lt;/p&gt;
&lt;p&gt;每个进程都有一个工作目录，有时称其为当前工作目录，所有的相对路径都是从工作目录开始解释，进程可以用&lt;code&gt;chrdir&lt;/code&gt;更改其工作目录。&lt;/p&gt;</summary><category term="Linux汇总"></category></entry><entry><title>Linux里的输入输出（Linux快速入门）</title><link href="http://www.yanyulin.info/pages/2014/02/linux2.html" rel="alternate"></link><updated>2014-02-22T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2014-02-22:pages/2014/02/linux2.html</id><summary type="html">&lt;p&gt;阅读本博文之前可以参考以下文章&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2014/02/linux1.html" target="_blank"&gt;
快速介绍Linux（Linux入门教程）
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Linux系统中每个文件均有一个文件描述符（文件描述符是一个整数），当内核打开一个文件或者创建一个文件时，返回一个文件描述符，读写文件就可以使用它&lt;/p&gt;
&lt;p&gt;在shell中运行的每个新程序都对应三个文件描述符，标准输入，村准输出，标准出错输出，简单命令&lt;code&gt;ls&lt;/code&gt;三个文件描述符都指向终端（&lt;strong&gt;linux中将设备都当作文件来操作&lt;/strong&gt;），&lt;code&gt;Shell&lt;/code&gt;中也提供了重定向文件输出，将输出重定向到某个文件如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ls&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将&lt;code&gt;ls&lt;/code&gt;的输出重定向到&lt;code&gt;file.txt&lt;/code&gt;（&lt;strong&gt;此时可以发现控制台上没有输出&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;输入输了关的函数&lt;/p&gt;
&lt;p&gt;不带缓冲的I/O函数有&lt;code&gt;open,read,write,lseek,close&lt;/code&gt;（&lt;code&gt;即中间没有一个缓存区作为过渡&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;a href="http://www.yanyulin.info/pages/2014/02/linux2.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/tech/linuxio.jpg" alt="烟雨林博客"/&gt;
&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;注解:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux系统中规定标准输入的文件描述符为0,标准输出为1,标准错误输出为2,&lt;code&gt;STDIN_FILENO&lt;/code&gt;与&lt;code&gt;STDOUT_FILENO&lt;/code&gt;分别指定了输入输出的来源&lt;/p&gt;
&lt;p&gt;Read函数返回读的字节数，当到达文件未尾时返回0，如果发生读错误返回-1&lt;/p&gt;
&lt;p&gt;标准I/O，标准I/O函数提供一种带缓冲的I/O函数，并简化了对输入出输出的处理，如fgets(标准函数)函数能读一个完整的行。而read（不带缓存）只能以字节读取。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;程序与进程&lt;/p&gt;
&lt;p&gt;程序的执行实例被称为进程，&lt;code&gt;Unix&lt;/code&gt;系统确保每个进程都有一个唯一的数字标识符，称为进程ID.&lt;/p&gt;
&lt;p&gt;进程控制的三个主要函数：&lt;code&gt;fork exec waitpid&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;示例程序：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;a href="http://www.yanyulin.info/pages/2014/02/linux2.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/tech/linuxio1.png" alt="烟雨林博客"/&gt;
&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;
&lt;p&gt;程序解释如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;标准I/O函数fgets从标准输入中一次读取一行，fgets读取的字符串以换行符做做为结束，面execlp要求其参数是以null结束，故要进行转换。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Fork&lt;/code&gt;创建新进程，新进程是调用进程的复制品，fork向父进程返回新创建进程的ID,对子进程而言，返回的是0,(&lt;strong&gt;fork调用一次，返回两次&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;父进程希望等待子进程终止，则需要调用函数waitpid函数，其参数为要等待进程的ID&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;线程与线程ID&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;线程的提出是为了利用多处理器的并行性，以及程序任务的划分。进程中的所有线程共享地址空间，文件描述符，堆栈，以及进程相关属性。正因为这些特性，才产生了线程的同步问题。&lt;/p&gt;
&lt;p&gt;线程也有ID,但ID只在它所属的进程内起作用，离开了其所属的进程，谈线程没意义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;出错处理：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文件&lt;errno.h&gt;中定义了符号errno(函数返回的错误代码)可被赋予的各种常量，这些常量均以字符E开头，如EMSGSIZE表示消息过长。    要使用errno需要包函&lt;errno.h&gt;这个头文件，同时在&lt;string.h&gt;中也提供了&lt;/p&gt;
&lt;p&gt;将错误代码转换成有意义的字符串操作函数如：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;strerror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;errno&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在&lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;中也提供了基于&lt;code&gt;errno&lt;/code&gt;在标准出错上产生一条出错消息的函数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;perror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;//输出msg指向的字符串，后一冒号，一空格，接着是errno值对应的出错信息，最后是一个换行符。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;示例程序如下：&lt;/p&gt;
&lt;p&gt;&lt;center&gt;
&lt;a href="http://www.yanyulin.info/pages/2014/02/linux2.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/tech/linuxio2.png" alt="烟雨林博客"/&gt;
&lt;/a&gt;
&lt;/center&gt;&lt;/p&gt;</summary><category term="Linux汇总"></category></entry><entry><title>pelican创建博客常见问题汇总</title><link href="http://www.yanyulin.info/pages/2014/01/pelican_question.html" rel="alternate"></link><updated>2014-01-08T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2014-01-08:pages/2014/01/pelican_question.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;1、No valid files found in content errors&lt;/p&gt;
&lt;p&gt;当用&lt;code&gt;pelican&lt;/code&gt;创建博客时出现此问题的原因是因为&lt;code&gt;pelican&lt;/code&gt;创建博客时读取到&lt;code&gt;contents&lt;/code&gt;目录下的md文件，而md文件需要&lt;code&gt;markdown&lt;/code&gt;的相库库解析，&lt;code&gt;pelican&lt;/code&gt;此时缺少该库，因此可以通过以下命令安装&lt;code&gt;markdown&lt;/code&gt;的相应库&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;pip&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;markdown&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你还没有安装&lt;code&gt;pip&lt;/code&gt;工具，可以参考下面一篇文章安装&lt;code&gt;pip&lt;/code&gt;工具&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2013/11/pelican.html" title="pelican搭建属于自已的博客"&gt;pelican搭建属于自已的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装完问题大概即可解决&lt;/p&gt;
&lt;p&gt;2、markdown即md文件中可不可以包含其他元数据?pelican要求md文件必须包含&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;XXX&lt;/span&gt;
&lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;XXX&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用户也可以创建自定义的元数据，例如给每一篇文章增加一个修改日期&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Modified&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2012&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;08&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;08&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在后绪的模板页中可以直接访问该元数据，例如在&lt;code&gt;article.html&lt;/code&gt;中可以使用以下代码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;article.modified&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;Last modified: &lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;article.modified&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;endif&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果需要在&lt;code&gt;article.html&lt;/code&gt;以外的地方使用该元数据，需要在使用的地方加上如下语句&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;article&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;article&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;modified&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3、如何禁用feed&lt;/p&gt;
&lt;p&gt;pelican中禁用feed的产生是非常容易的，只需要在配置文件&lt;code&gt;pelicanconf.py&lt;/code&gt;中加入如下几条语句即可完成&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;FEED_ALL_ATOM&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;None&lt;/span&gt;
&lt;span class="n"&gt;CATEGORY_FEED_ATOM&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;None&lt;/span&gt;
&lt;span class="n"&gt;TRANSLATION_FEED_ATOM&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;None&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;4、warning about feeds generated without SITEURL being set properly&lt;/p&gt;
&lt;p&gt;RSS and Atom feeds要求URL必须是绝对链接，而不是相对链接，因此为了产生正确的链接，pelican要求在配置文件中必须设置SITEURL选项，否则产生的RSS与Feeds可能不正确&lt;/p&gt;
&lt;p&gt;5、如何给一篇文章指定URL&lt;/p&gt;
&lt;p&gt;在需要指定URL的文章或者页面中包括两个元数据&lt;code&gt;url&lt;/code&gt;与&lt;code&gt;save_as&lt;/code&gt;,例如以下代码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;override&lt;/span&gt;&lt;span class="sr"&gt;/url/&lt;/span&gt;
&lt;span class="n"&gt;save_as&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;override&lt;/span&gt;&lt;span class="sr"&gt;/url/i&lt;/span&gt;&lt;span class="n"&gt;ndex&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个代码指定了本篇文章的url为override/url/index.html&lt;/p&gt;
&lt;p&gt;6、如何将一篇文章设置为主页&lt;/p&gt;
&lt;p&gt;根据上面的第5条很容易将一篇文章设置为网站的主页，如下代码即可实现将 content/pages/home.md设为主页&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nl"&gt;Title:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;www&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;yanyulin&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//www.yanyulin.info)&lt;/span&gt;
&lt;span class="nl"&gt;Date:&lt;/span&gt; &lt;span class="mi"&gt;2014&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mo"&gt;01&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;08&lt;/span&gt;
&lt;span class="nl"&gt;URL:&lt;/span&gt;
&lt;span class="nl"&gt;save_as:&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;html&lt;/span&gt;
&lt;span class="err"&gt;文章正文内容&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;7、如何给一篇文章指定一个特定模板&lt;/p&gt;
&lt;p&gt;给一篇文章指定一个特定的模板也很简单，只需要在文章中添加如下元数据，并且确保该模板文件在模板中存在即可&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Template&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;template_name&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;8、如果还不知道怎么使用pelican创建博客，看如下教程&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2013/11/pelican.html" title="pelican搭建属于自已的博客"&gt;pelican搭建属于自已的博客&lt;/a&gt;&lt;/p&gt;</summary><category term="工具使用"></category></entry><entry><title>.htaccess简明教程(SEO优化)</title><link href="http://www.yanyulin.info/pages/2013/12/htaccess.html" rel="alternate"></link><updated>2013-12-23T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2013-12-23:pages/2013/12/htaccess.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;.htaccess文件可以用来优化网站，尽管.htaccess只是一个文件，但它可以更改服务器的设置，允许你做许多不同的事情，最流行的功能是可以创建自定义的“404 error”页面，.htaccess并不难，你可以给它想像成就是一个文本文件再加几条服务器的配置命令&lt;/p&gt;
&lt;p&gt;确定服务器是否支持.htaccess&lt;/p&gt;
&lt;p&gt;如果主机是&lt;code&gt;unix&lt;/code&gt;或&lt;code&gt;Linux&lt;/code&gt;系统，或任何版本的&lt;code&gt;Apache&lt;/code&gt;网络服务器，理论上都是支持&lt;code&gt;.htaccess&lt;/code&gt;的,除非你的服务器提供商禁用了&lt;code&gt;.htacess&lt;/code&gt;文件&lt;/p&gt;
&lt;p&gt;.htaccess的主要功能:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1:文件夹密码保护&lt;/p&gt;
&lt;p&gt;2:用户自动重定向&lt;/p&gt;
&lt;p&gt;3:自定义错误页面&lt;/p&gt;
&lt;p&gt;4:改变你的文件扩展名&lt;/p&gt;
&lt;p&gt;5:封禁特定IP地址的用户&lt;/p&gt;
&lt;p&gt;6:只允许特定IP地址的用户&lt;/p&gt;
&lt;p&gt;7:禁止目录列表&lt;/p&gt;
&lt;p&gt;8:使用其他文件作为index文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;创建&lt;code&gt;.htaccess&lt;/code&gt;文件&lt;/p&gt;
&lt;p&gt;Linux/unix以及一些其他类unix系统中可以直接单击右键进行创建，然后将文件命名为.htaccess，或者使用命令行工具&lt;code&gt;touch .htaccess&lt;/code&gt;命令创建&lt;/p&gt;
&lt;p&gt;Window系统下就有些麻烦啦，Windows会把.htaccess当作文件扩展名，一个文件没有名称只有扩展名是不允许被创建的，因此你可以先创建一个普通文件，上传到服务器上，如果服务器提供了在线更改，可以直接在线更改文件名，如果没有提供，可以通过FTP软件来进行更改，还有一种方式，可以在Windows下，下载一些能运行Linux/Unix命令的工具，如&lt;code&gt;git bash&lt;/code&gt;,在&lt;code&gt;git bash&lt;/code&gt;上输入&lt;code&gt;touch .htaccess&lt;/code&gt;同样可以创建&lt;/p&gt;
&lt;p&gt;.htaccess文件编写&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;自定义错误页：通过自定义错误页将使你可以拥有个性化的错误处理页面，而不是你的主机提供商给你提供的错误页或没有任何页面&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;什么时候会出现错误页,最简单的例子就是当用户访问你网站上并不存在的页面时，出现的那个页面就是错误页&lt;/p&gt;
&lt;p&gt;例子，将所有的404 error错误处理页转变成网站的首页(最通俗的理解就是当用户访问了网站上并不存在的页面时直接跳到首页上去)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ErrorDocument 404 /index.html&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从上面的命令可以推出其他命令的处理方式，代码如下&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rrorDocument 错误处理代号 错误处理页面&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;例如对服务器返回的500指定错误处理页面&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ErrorDocument 500 /500.html&lt;/code&gt; 如果文件不在根目录下可以写成/目录名/文件名&lt;/p&gt;
&lt;p&gt;401 - Authorization Required 需要验证&lt;/p&gt;
&lt;p&gt;400 - Bad request 错误请求&lt;/p&gt;
&lt;p&gt;403 - Forbidden 禁止&lt;/p&gt;
&lt;p&gt;500 - Internal Server Error 内部服务器错误&lt;/p&gt;
&lt;p&gt;404 - Wrong page 找不到页面&lt;/p&gt;
&lt;p&gt;命令写法同上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;禁止显示网站的目录列表，当网站根目录下没有index.html，用户通过域名访问网站时会将整个网站的目录显示给用户,禁止方法如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Options -Indexes&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;禁止或者允许特定IP地址访问网站&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;禁止特定的IP地址访问，命令如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;deny from 000.000.000.000&lt;/code&gt;  其中&lt;code&gt;000.000.000.000&lt;/code&gt;代表的是特定的IP地址，如果只指明其中的几个，则可以封禁整个网段的地址。如你输入&lt;code&gt;112.27.38.&lt;/code&gt;，则将封禁&lt;code&gt;112.27.38.0～112.27.38.255&lt;/code&gt;的所有IP地址&lt;/p&gt;
&lt;p&gt;禁止所有人访问，用以下命令&lt;/p&gt;
&lt;p&gt;&lt;code&gt;deny from all&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;允许特定的IP地址访问，命令如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;allow from 000.000.000.000&lt;/code&gt; 如果只指明其中的几个，则可以允许某个网段的地址。如你输入&lt;code&gt;112.27.38.&lt;/code&gt;，则将允许&lt;code&gt;112.27.38.0～112.27.38.255&lt;/code&gt;的所有IP地址访问网站&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;index的替换文件,默认情况下，如果网站下没有index.&lt;code&gt;*&lt;/code&gt;(&lt;code&gt;*&lt;/code&gt;可以代表&lt;code&gt;php&lt;/code&gt;,&lt;code&gt;html&lt;/code&gt;,&lt;code&gt;htm&lt;/code&gt;,&lt;code&gt;jsp&lt;/code&gt;)
在.htaccess中也没有禁止将目录显示出来，当用户通过域名访问网址时，会将整个网址的目录列出来，通过指定&lt;code&gt;index.*&lt;/code&gt;替换文件，可以在服务器不存在&lt;code&gt;index.*&lt;/code&gt;文件的情况下，使用该文件代替。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;DirectoryIndex index.php index.php3 messagebrd.pl index.html index.htm&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;重定向相关的命令(&lt;strong&gt;最重要的&lt;/strong&gt;),重定向就是将请求重定向到同站内或站外的不同文档，这在你改变了一个文件名称，但仍然想让用户用旧地址访问到它时，变的极为有用，同时也可以通过重定向，将长url变成短url&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;重定向的相关例子&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Redirect /loc/file/dir/file.html http://www.othersite.com/sample.html&lt;/code&gt; 将网址上访问特定的url重定向到其他网址&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Redirect /oldDir http://www.newsite.com/newDir&lt;/code&gt;目录重定向，任何指向站点/oldDir目录的请求都将被重新指向新的站点,例如当用户访问&lt;code&gt;http://www.youroldsite.com/oldDir/index.html&lt;/code&gt;将会被重定向到&lt;code&gt;http://www.newsite.com/newDir/index.html&lt;/code&gt;（这里的www.youroldsite.com就是网站的域名，如&lt;a href="http://www.yanyulin.info"&gt;www.yanyulin.info&lt;/a&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;密码保护&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;.htaccess用于网站目录的密码保护具有完美的安全性（即访问者必须知晓密码才可以访问目录，并且绝无“后门”可走）&lt;/p&gt;
&lt;p&gt;相关命令，利用.htaccess将一个目录加上密码保护分两步，一：是在你的.htaccess文档里加上适当的几行代码，二是将.htaccess文档放进你要保护的目录下，代码如下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;AuthName&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Section Name&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;AuthType&lt;/span&gt; &lt;span class="n"&gt;Basic&lt;/span&gt;
&lt;span class="n"&gt;AuthUserFile&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;full&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;htpasswd&lt;/span&gt;
&lt;span class="n"&gt;Require&lt;/span&gt; &lt;span class="n"&gt;valid&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;/full/parth/to/.htpasswd&lt;/code&gt;则应该替换为指向&lt;code&gt;.htpasswd&lt;/code&gt;文件,.htpasswd也是一个没有文件名文档，可以放置在你网站里的任何地方（此时&lt;code&gt;密码应加密&lt;/code&gt;），但建议你将其保存在网站Web根目录外，这样通过网络就无法访问到它了,文件里的内容是username:password(用户名:密码)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;</summary><category term="工具使用"></category></entry><entry><title>pelican搭建属于自已的博客</title><link href="http://www.yanyulin.info/pages/2013/11/pelican.html" rel="alternate"></link><updated>2013-11-24T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2013-11-24:pages/2013/11/pelican.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;一直都想搭建一个属于自已的博客，无耐总是抽不出时间，9月份完工作，10月份却又有搞不完的事，一拖再拖，前不久才将自已的博客搭建完成&lt;/p&gt;
&lt;p&gt;搭建博客工具的选择：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WordPress&lt;/code&gt;、&lt;code&gt;Zblog&lt;/code&gt;、各种&lt;code&gt;cms&lt;/code&gt;,功能都很强大，各种插件，各种牛X，各种方便，但在我看来，也正是因为功能的太过强大，显得太笨重，修改起来太过麻烦，更可耻的是还需要数据库的支持，我这样的叼丝学生估计还负担不起，而国外提供免费数据库的空间绝大多数都不太稳定，国内空间别提了，各种泪&lt;/p&gt;
&lt;p&gt;静态博客生成器:&lt;code&gt;Jeklly&lt;/code&gt;非常棒，基于&lt;code&gt;octopress&lt;/code&gt;也相当的不错，可惜都是基于ruby语言的，对ruby语言压根就不了解，最终选择了基于&lt;code&gt;python&lt;/code&gt;的&lt;code&gt;pelican&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pelican&lt;/code&gt;搭建博客需要了解的名词&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Github&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;python&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pelican&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Jinja2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;markdown&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sitemap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pip&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最初是在Linux下搭建博客，正在捉急的进行到一半途中，linux系统让我弄的崩溃了，最后是在Windows下搭建完成，不过linux下是类似的，因为搭建过程是在Git Bash中完成，Git Bash中的命令就是仿unix的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前提了解github的使用，可以看看我写的Github相关文章&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、&lt;a href="http://www.yanyulin.info/pages/2013/11/github.html"&gt;Github简明教程(入门篇)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href="http://www.yanyulin.info/pages/2013/11/githubM.html"&gt;Github上如何给别人贡献代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;步骤一：下载相关的软件，&lt;code&gt;pelican&lt;/code&gt;是基于&lt;code&gt;python&lt;/code&gt;的，因此&lt;code&gt;python&lt;/code&gt;是不可少的，与&lt;code&gt;github&lt;/code&gt;进行连接
&lt;code&gt;git&lt;/code&gt;工具也是不可少的，另外还得下载的三个工具是&lt;code&gt;python&lt;/code&gt;的&lt;code&gt;pip&lt;/code&gt;工具以及&lt;code&gt;markdownpad&lt;/code&gt;编辑器还有&lt;code&gt;Windows&lt;/code&gt;下的&lt;code&gt;make&lt;/code&gt;工具，如果是在linux下，此处工作相当简单，相关软件的下载链接，请查看我个人博客的原始博文&lt;/p&gt;
&lt;p&gt;1、&lt;a href="http://yunpan.cn/QUF66GnJ7WU7W" target="_blank"&gt;python3下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href="http://yunpan.cn/QUF6BFpTcgeLc" target="_blank"&gt;git下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href="http://yunpan.cn/QUF66RuY8ziq5" target="_blank"&gt;pip下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href="http://yunpan.cn/QUF6BpkxgdpLb" target="_blank"&gt;windows下make下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a href="http://yunpan.cn/QUF66w7tQLcQd" target="_blank"&gt;markdown下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;pip&lt;/code&gt;工具的安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;python3&lt;/code&gt;下安装pip&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//已安装python3&lt;/span&gt;
&lt;span class="c1"&gt;//下载easy_install的tar.gz的源码&lt;/span&gt;
&lt;span class="c1"&gt;//然后解压&lt;/span&gt;
&lt;span class="nl"&gt;C:&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;python32&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;python&lt;/span&gt; &lt;span class="n"&gt;setup&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt;
&lt;span class="nl"&gt;C:&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;python32&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;Scripts&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="n"&gt;easy_install&lt;/span&gt; &lt;span class="n"&gt;pip&lt;/span&gt;
&lt;span class="c1"&gt;//把C:\python32\Scripts这个路径也加到PATH里&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;code&gt;window&lt;/code&gt;下make工具的安装&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//将下载的`make.exe`文件添加到path路径中&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;基他软件直接点击exe安装即可&lt;/p&gt;
&lt;p&gt;步骤二:安装&lt;code&gt;pelican&lt;/code&gt;,安装了&lt;code&gt;Git&lt;/code&gt;后，打开&lt;code&gt;Git Bash&lt;/code&gt;输入以下命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;pip&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;pelican&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;步骤三:创建博客，在Git Bash命令行窗口中输入如下命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;mkdir&lt;/span&gt; &lt;span class="n"&gt;blog&lt;/span&gt;
&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;blog&lt;/span&gt;
&lt;span class="n"&gt;pelican&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;quickstart&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第三条命令执行后会提示你输入博客的配置项，除了&lt;code&gt;SITENAME&lt;/code&gt;配置项外，其他均可选择默认，在后绪的开发过程中，可以在&lt;code&gt;pelicanconf.py&lt;/code&gt;中进行修改，执行完上述命令后，即可生成一个基本的博客架构，如下图所示&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;blog&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt;  &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;存放你要写的博客&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;   &lt;span class="err"&gt;└──&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pages&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="err"&gt;#单纯的页面&lt;/span&gt;
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;   &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;生成的输出文件&lt;/span&gt;
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;develop_server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;方便开启测试服务器&lt;/span&gt;
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;Makefile&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;方便管理博客的&lt;/span&gt;&lt;span class="n"&gt;Makefile&lt;/span&gt;
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;pelicanconf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;   &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;主配置文件&lt;/span&gt;
&lt;span class="err"&gt;└──&lt;/span&gt; &lt;span class="n"&gt;publishconf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;   &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;主发布文件，可删除&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用&lt;code&gt;markdown&lt;/code&gt;写博文，要记住的是博文必须放在&lt;code&gt;content&lt;/code&gt;目录下，&lt;code&gt;pelican&lt;/code&gt;会将&lt;code&gt;content&lt;/code&gt;目录下的所有文章输出到&lt;code&gt;output&lt;/code&gt;目录下，然后放到服务器上，&lt;code&gt;markdown&lt;/code&gt;写博文的预览图如下：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2013/11/pelican.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/markdown.jpg"   alt="烟雨林博客" width="100%"/&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;写完后执行如下命令，即可在本机上预览博客,预览地址为&lt;code&gt;http://localhost:8000/&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;publish&lt;/span&gt;
&lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;serve&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;步骤四:将博客部署到&lt;code&gt;github&lt;/code&gt;上，博客最终是要放到互联网上供人看的，此处就是将博客上传上去，在上传之前，要确保&lt;code&gt;github&lt;/code&gt;上有一个仓库命令规是&lt;code&gt;username.github.io&lt;/code&gt;,其中&lt;code&gt;username&lt;/code&gt;为你的&lt;code&gt;github&lt;/code&gt;帐号&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//切换到输出目录&lt;/span&gt;
&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="k"&gt;output&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;remote&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="nl"&gt;https:&lt;/span&gt;&lt;span class="c1"&gt;//github.com/username.github.io.git&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;pull&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="n"&gt;master&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;commit&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="p"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;commit&lt;/span&gt;&lt;span class="p"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="n"&gt;master&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;执行完上面命令后即将博客上传至&lt;code&gt;github&lt;/code&gt;服务器上，打开浏览器输入&lt;code&gt;http://username.github.io&lt;/code&gt;即可访问，如果你觉的上面的命令过于复杂，你也直接可以将其添加到Makefile中&lt;/p&gt;
&lt;p&gt;步骤五:给博客挑选主题，博客的初始主题当然是不好看，你可以自已下载&lt;code&gt;pelican&lt;/code&gt;相关的主题，然后安装，当然你也可以像我一样更改主题模板，创建属于自已的&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//github.com/getpelican/pelican-themes.git&lt;/span&gt;
&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;pelican&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;themes&lt;/span&gt;
&lt;span class="n"&gt;pelican&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;themes&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="n"&gt;bootstrap2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在&lt;code&gt;pelicanconf.py&lt;/code&gt;中添加&lt;code&gt;THEME = 'bootstrap2'&lt;/code&gt;即可，然后重新&lt;code&gt;make publish&lt;/code&gt;即可&lt;/p&gt;
&lt;p&gt;步骤六：给博客加上评论系统，在Disqus上申请一个站点，记牢Shortname。 在pelicanconf.py添加如下命令，当然你也可以选择国内的多说或者其他的&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;DISQUS_SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Shortname&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;步骤七：给自已的博客加上谷歌分析，可选，去去Google Analytics申请账号，记下跟踪ID。 在pelicanconf.py添加&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;GOOGLE_ANALYTICS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;跟踪&lt;/span&gt;&lt;span class="n"&gt;ID&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;步骤入：独立域名与DNS解析&lt;/p&gt;
&lt;p&gt;在Godaddy上用支付宝花购买为期一年的顶级域名，并去修改Nameservers为这两个地址：&lt;code&gt;f1g1ns1.dnspod.net&lt;/code&gt;、&lt;code&gt;f1g1ns2.dnspod.net&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在Dnspod上添加新域名，并申请一条A记录指向Github Pages的ip:&lt;code&gt;207.97.227.245&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;在Pelican主目录新建CNAME文件，添上刚刚申请的域名，如我的&lt;code&gt;www.yanyulin.info&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Pelican官方文档: http://docs.getpelican.com/en/3.2&lt;/p&gt;</summary><category term="工具使用"></category></entry><entry><title>Github上如何给别人贡献代码</title><link href="http://www.yanyulin.info/pages/2013/11/githubM.html" rel="alternate"></link><updated>2013-11-22T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2013-11-22:pages/2013/11/githubM.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;本篇博文仅随前篇博文&lt;a href="http://www.yanyulin.info/pages/2013/11/github.html" title="Github简明教程(入门篇)"&gt;&lt;code&gt;Github&lt;/code&gt;简明教程(入门篇)&lt;/a&gt;，当然我的独立博客也是采用Github搭建，我所介绍的Github正是我搭建博客过程中一点一点学习的过程，如有错误，还请指出，同样大神们可以绕过。&lt;/p&gt;
&lt;p&gt;本篇重点介绍&lt;code&gt;Github&lt;/code&gt;上如何给别人贡献代码，通过这个过程，也可以知道如果一个项目托管到Github上，团队成员之间合作的流程，给别人贡献代码，特别是一些开源组织，是件光荣的事&lt;/p&gt;
&lt;p&gt;1、搜索你要贡献的代码仓库，在这里我创建了两个帐号，一个主帐号，里面有一个代码仓库mfjc，一个是将要贡献代码的帐号howard5888,搜索代码仓库如下图：
&lt;a href="http://www.yanyulin.info/pages/2013/11/githubM.html" target="_blank"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/2github1.jpg"  alt="烟雨林博客" width="100%"/&gt;
&lt;/a&gt;
2、按下回车后，即会出现搜索到的库，如下图所示
&lt;a href="http://www.yanyulin.info/pages/2013/11/githubM.html" target="_blank"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/2github2.jpg" width="100%"  alt="烟雨林博客"/&gt;
&lt;/a&gt;
3、点击上图中的仓库链接，进入mfjc仓库，点击右边的fork,fork的含义就是创建mfjc项目的副本作为你自已的项目
&lt;a href="http://www.yanyulin.info/pages/2013/11/githubM.html" target="_blank"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/2github3.jpg"  alt="烟雨林博客" width="100%"/&gt;
&lt;/a&gt;
4、fork之后的图如下图所示，从下图可以看出mfjc已经处于自已的github帐号库中，同时也可以发现github还标明了该库的来源，因为只有标明了来源，后面你修改了文件才有提交的路径
&lt;a href="http://www.yanyulin.info/pages/2013/11/githubM.html" target="_blank"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/2github3.jpg" alt="烟雨林博客" width="100%"/&gt;
&lt;/a&gt;
5、修改或者增加仓库里的文件，可以选择在线修改，在线修改一般适合修改量较少，这里介绍的是采用Git工具，将代码仓库下载到本地，在本地修改之后再上传上去，相关命令如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;mkdir&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="err"&gt;#创建&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="err"&gt;目录&lt;/span&gt;
&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt; &lt;span class="err"&gt;#切换到&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="err"&gt;目录&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt; &lt;span class="err"&gt;#创建并初始化&lt;/span&gt;&lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="err"&gt;库&lt;/span&gt;
&lt;span class="cp"&gt;#增加远程git仓库&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;remote&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//github.com/howard5888/mfjc.git&lt;/span&gt;
&lt;span class="cp"&gt;#将远程git库下载到本地&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;pull&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="n"&gt;master&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;6、命令执行完后，可以看看从mfjc下载下来的文件，如下图所示
&lt;a href="http://www.yanyulin.info/pages/2013/11/githubM.html" target="_blank"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/2github5.jpg"   alt="烟雨林博客" width="100%" height="30px"/&gt;
&lt;/a&gt;
7、假设我们修改了README.md文件，在这个文件里面增加了#test#，接下来要做的就是将修改后的代码库上传上去，命令如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#会将当前目录tmp下所有文件都增加到本地库中&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="cp"&gt;#提交更改&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;commit&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;commit&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="cp"&gt;#将库上传到github上&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="n"&gt;master&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;8、上传完后，再回到github网站上，可以看到README.md文件内容已更改
&lt;a href="http://www.yanyulin.info/pages/2013/11/githubM.html" target="_blank"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/2github6.jpg"  alt="烟雨林博客" width="100%"/&gt;
&lt;/a&gt;
9、最后就是将修改提交给主帐号的原作者，由它来决定是否合并你的修改，操作如下，点击Pull request后，跳转到下一个页面，在下一个页面上点击New pull Request
&lt;a href="http://www.yanyulin.info/pages/2013/11/githubM.html" target="_blank"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/2github7.jpg"  alt="烟雨林博客"  width="100%"/&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;10、接下来的界面上显示了修改后的文件与原作者库里的文件有哪些地方不同
&lt;a href="http://www.yanyulin.info/pages/2013/11/githubM.html" target="_blank"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/2github8.jpg"   alt="烟雨林博客" width="100%"/&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;11、然后点击Click to create ....即可跳转到最后一个页面，在最后一个页面上写上自已的提交注释，点击Send Request即可
&lt;a href="http://www.yanyulin.info/pages/2013/11/githubM.html" target="_blank"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/2github9.jpg"  alt="烟雨林博客"   width="100%"/&gt;
&lt;/a&gt;
12、主帐号里的源作者即可收到你的提交请求，如果觉的可以的话，就会将你的请求同主干合并&lt;/p&gt;
&lt;p&gt;13、估计还有很多人不知道如何与原作者的项目保持同步，&lt;strong&gt;如何保持与原作者同步&lt;/strong&gt;，原作者估计肯定是一个勤劳的码神，而且又有重多的贡献者，因此与原作者保持同步是很重要的，而且在同步的过程中，你会看到别人每次提交的更改，&lt;strong&gt;这也是Github最大的价值之一&lt;/strong&gt;，保持与原作者同步首先要做的就是重复第9步，之后会跳到如下页面&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2013/11/githubM.html" target="_blank"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/2github10.jpg"  alt="烟雨林博客"   width="100%"/&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;14、点击上图中的红色框里，跳转到下一个页面，在下一个页面中，你会看到项目中的每次更新操作，如下图所示：
&lt;a href="http://www.yanyulin.info/pages/2013/11/githubM.html" target="_blank"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/2github11.jpg"  alt="烟雨林博客"    width="100%"/&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;15、点击绿色方框里的Create...，进入下一个页写，写上title以及comment,点击Send pull,即可跳转到下一个页面，在下一个页面中间处点击Merge request,即可进行同步
&lt;a href="http://www.yanyulin.info/pages/2013/11/githubM.html" target="_blank"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/2github12.jpg"  alt="烟雨林博客"    width="100%"/&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下一篇将介绍如何利用Github搭建属于自已的博客&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info" title="烟雨林个人博客"&gt;烟雨林个人博客&lt;/a&gt;&lt;/p&gt;</summary><category term="工具使用"></category></entry><entry><title>Github简明教程(入门篇)</title><link href="http://www.yanyulin.info/pages/2013/11/github.html" rel="alternate"></link><updated>2013-11-20T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2013-11-20:pages/2013/11/github.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;Github作为一项目托管仓库，里面有着各种各样的高质量代码，本篇博客针对Git入门或者初学者，各位大神可以绕过，关于GitHub的强大之处可以自已百度谷歌去，在继续阅读本篇博客之前，如果还没有帐号的同学，先到github官网上申请一个帐号http://www.github.com&lt;/p&gt;
&lt;p&gt;1、首先登录自已的帐号，创建属于自已的代码库
&lt;a href="http://www.yanyulin.info" target="_blank"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/github1.jpg"  alt="烟雨林博客"  width="100%"/&gt;
&lt;/a&gt;
2、然后跳转下一个页面，填写&lt;code&gt;repository name&lt;/code&gt;,如：TEST，在&lt;code&gt;Add .gitgore&lt;/code&gt;一项根据你所使用语言选择，其他的默认，然后&lt;code&gt;creat repository&lt;/code&gt;
&lt;a href="http://www.yanyulin.info" target="_blank"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/github2.jpg"  alt="烟雨林博客"  width="100%"/&gt;
&lt;/a&gt;
做完上面的后，GitHub就生成了一个代码仓库，目前仓库中仅有三个文件，.gitingore/LICENSE/README.md,以及相应的远程仓库地址，这个地址可以使用git工具进行代码的下载与上传
&lt;a href="http://www.yanyulin.info" target="_blank"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/github3.jpg"   alt="烟雨林博客" width="100%"/&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.你可以点击上图中Test后面的&lt;code&gt;+&lt;/code&gt;号新创建一个文件，或者直接选中页面中的一个文件对其进行修改以及删除，但是一般不采用这种方式，这种方式修改的效率太低，一般采用的方式均是通过git工具，将代码下载到
本地，在本地修改后，然后再上传到github托管的代码库中，例如如下（前提是已安装了git工具)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;mkdir&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;
&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;
&lt;span class="n"&gt;touch&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;md&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;md&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;commit&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;am&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;commit&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt; 
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;remote&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//github.com/howard5888/TEST.git&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;pull&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="n"&gt;master&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="n"&gt;master&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;执行完上述命令后，再看看github里TEST仓库，就可以发现自已新增的文件test.md了
&lt;a href="http://www.yanyulin.info" target="_blank"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/github4.jpg"  alt="烟雨林博客" width="100%"/&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;执行完上面的代码后，打开github的TEST仓库，可以看到TEST仓库里多了一个test.md文件，上面命令中howard5888实际输入时要替换成自已的帐户号，在执行上面的命令上传文件时，会要求用户输入自已的用户名与秘密，在输入的过程中，是不回显的&lt;/p&gt;
&lt;p&gt;相关命令解释如下:&lt;/p&gt;
&lt;p&gt;1、mkdir tmp 在当前目录下创建一个新的目录 tmp&lt;/p&gt;
&lt;p&gt;2、cd tmp 切换到tmp目录下&lt;/p&gt;
&lt;p&gt;3、git init tmp目录作为一个本地仓库，初始库git库&lt;/p&gt;
&lt;p&gt;4、touch test.md 在当前目录下创建了文件 test.md&lt;/p&gt;
&lt;p&gt;5、git add test.md 将test.md文件增加到本地git库中&lt;/p&gt;
&lt;p&gt;6、git commit -am 'commit' 提交，让上条增加文件命令生效&lt;/p&gt;
&lt;p&gt;7、git remote add 向本地仓库中填加远程仓库地址，远程仓库地址别名是origin&lt;/p&gt;
&lt;p&gt;8、git pull origin master 将orgin所代表的远程仓库地址里的master主干下载到本地仓库，即上传之 前先进行一次同步&lt;/p&gt;
&lt;p&gt;9、git push -u origin master将本地仓库上传到origin所代表的远程仓库的master分支上&lt;/p&gt;
&lt;p&gt;知道了在Github上如何创建仓库，可能还有很多人不知道如何去删除一个仓库，Github上删除仓库也是很容易的，就是有点难找，以删除TEST仓库为例，点击仓库右边的setting
&lt;a href="http://www.yanyulin.info" target="_blank"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/github5.jpg"  alt="烟雨林博客"   width="100%"/&gt;
&lt;/a&gt;
跳转进入下一个页面，在页面最下方，就有如下图所示的删除铵钮
&lt;a href="http://www.yanyulin.info" target="_blank"&gt;
&lt;img src="http://www.yanyulin.info/pics/tools/github6.jpg"  alt="烟雨林博客" width="100%"/&gt;
&lt;/a&gt;&lt;/p&gt;</summary><category term="工具使用"></category></entry><entry><title>Linux中0号进程的创建分析</title><link href="http://www.yanyulin.info/pages/2013/11/linux0.html" rel="alternate"></link><updated>2013-11-19T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2013-11-19:pages/2013/11/linux0.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt;中1号进程是由0号进程来创建的，因此必须要知道的是如何创建0号进程，由于在创建进程时，程序一直运行在内核态，而进程运行在用户态，因此创建0号进程涉及到特权级的变化，即从特权级0变到特权级3，&lt;code&gt;Linux&lt;/code&gt;是通过模拟中断返回来实现特权级的变化以及创建0号进程，通过将0号进程的代码段选择子以及程序计数器&lt;code&gt;EIP&lt;/code&gt;直接压入内核态堆栈，然后利用iret汇编指令中断返回跳转到0号进程运行。&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;move_to_user_mode&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="c1"&gt;//创建0号进程，开始进入0号进程，切换到特权级3运行&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;fork&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="err"&gt;｝&lt;/span&gt;&lt;span class="c1"&gt;//创建1号进程&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;跟踪代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#define move_to_user_mode() \&lt;/span&gt;
&lt;span class="cp"&gt;__asm__ (&amp;quot;movl %%esp,%%eax\n\t&amp;quot; \&lt;/span&gt;&lt;span class="c1"&gt;//将esp寄存器的内容存入eax中&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;pushl $0x17&lt;/span&gt;&lt;span class="se"&gt;\n\t&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="c1"&gt;//压入0号任务的数据段选择符&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;pushl %%eax&lt;/span&gt;&lt;span class="se"&gt;\n\t&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="c1"&gt;//压入堆栈指针&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;pushfl&lt;/span&gt;&lt;span class="se"&gt;\n\t&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="c1"&gt;//压入标志寄存器&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;pushl $0x0f&lt;/span&gt;&lt;span class="se"&gt;\n\t&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="c1"&gt;//压入0号任务的代码段选择符&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;pushl $1f&lt;/span&gt;&lt;span class="se"&gt;\n\t&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="c1"&gt;//压入EIP，即切换到0号任务后CPU运行的位置&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;iret&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="c1"&gt;//中断返回指令&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;1:&lt;/span&gt;&lt;span class="se"&gt;\t&lt;/span&gt;&lt;span class="s"&gt;movl $0x17,%%eax&lt;/span&gt;&lt;span class="se"&gt;\n\t&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="c1"&gt;//由于发生了切换，需要更改各段寄存器&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;movw %%ax,%%ds&lt;/span&gt;&lt;span class="se"&gt;\n\t&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="c1"&gt;//更改段寄存器ds&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;movw %%ax,%%es&lt;/span&gt;&lt;span class="se"&gt;\n\t&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="c1"&gt;//更改段寄存器es&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;movw %%ax,%%fs&lt;/span&gt;&lt;span class="se"&gt;\n\t&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="c1"&gt;//更改段寄存器fs&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;movw %%ax,%%gs&amp;quot;&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="c1"&gt;//更改段寄存器gs&lt;/span&gt;
    &lt;span class="o"&gt;:::&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ax&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;分析如下,注释已经很清楚：&lt;/p&gt;
&lt;p&gt;代码为嵌入汇编语句的C程序，&lt;code&gt;::”ax”&lt;/code&gt;表示的是输出为空，输入为空，在这个宏定义的执行过程中可以发生改变的是&lt;code&gt;ax&lt;/code&gt;寄存器，这属于GNU的gas语法，不作解释&lt;/p&gt;
&lt;p&gt;&lt;code&gt;0x17&lt;/code&gt;与&lt;code&gt;0x0f&lt;/code&gt;的真实意义，跟踪查看前先写成二进制形式&lt;code&gt;0x17=0000 0000 0001 0111&lt;/code&gt;,&lt;code&gt;0x0f=0000 0000 0000 1111&lt;/code&gt;;&lt;code&gt;0x17&lt;/code&gt;与&lt;code&gt;0x0f&lt;/code&gt;的后三们均是111，段选择子的后三位分别表示RPL以及TI,因此后三位即表示请示特权级为3，描述符在LDT中，故0x17与0x0f分别表示LDT中的第二项与第一项，即然是LDT表，在使用之前肯定要进行初始化，帮初始化代码肯定在move_to_user_mode之前，跟踪分析可以发现在&lt;code&gt;sched_init&lt;/code&gt;中，源码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;sched_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;//desc_struct表示是描述符表类型typedef struct desc_struct{a,b}desc_table[256];&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;desc_struct&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;sigaction&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;panic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Struct sigaction MUST be 16 bytes&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//这里开始是关键部分，gdt是全局描述符表的基地址&lt;/span&gt;
&lt;span class="c1"&gt;//FIRST_TSS_ENTRY与FIRST_LDT_ENTRY分别是4，5即全局描述符表中的第4项&lt;/span&gt;
&lt;span class="c1"&gt;//与第五项代表的是第一个任务，对其进行设置&lt;/span&gt;
&lt;span class="c1"&gt;//查看static union task_union init_task = {INIT_TASK,};可以看到INIT_TASK可以看到//INIT_TASK是个宏定义，即下面的注释&lt;/span&gt;
    &lt;span class="n"&gt;set_tss_desc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdt&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;FIRST_TSS_ENTRY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;init_task&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tss&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;set_ldt_desc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gdt&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;FIRST_LDT_ENTRY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;init_task&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ldt&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="c1"&gt;//p指向GDT表中0号任务的下一个位置，即GDT表中第6项&lt;/span&gt;
    &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gdt&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;FIRST_TSS_ENTRY&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;//NR_TASKS是Linux 0.11中最多支持的进程数64个&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;NR_TASKS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;task&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;//重复两次是因为每个进程对应一个LDT与一个TSS&lt;/span&gt;
        &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;//将标志寄存器的NT位禁止&lt;/span&gt;
    &lt;span class="n"&gt;__asm__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;pushfl ; andl $0xffffbfff,(%esp) ; popfl&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//#define ltr(n) __asm__(&amp;quot;ltr %%ax&amp;quot;::&amp;quot;a&amp;quot; (_TSS(n)))这是宏定义，很显然吧&lt;/span&gt;
&lt;span class="c1"&gt;//加载当前的任务寄存器与ldtr寄存器&lt;/span&gt;
    &lt;span class="n"&gt;ltr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//#define lldt(n) __asm__(&amp;quot;lldt %%ax&amp;quot;::&amp;quot;a&amp;quot; (_LDT(n)))&lt;/span&gt;
    &lt;span class="n"&gt;lldt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//定时器8253的初始化&lt;/span&gt;
    &lt;span class="n"&gt;outb_p&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x36&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mh"&gt;0x43&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="cm"&gt;/* binary, mode 3, LSB/MSB, ch 0 */&lt;/span&gt;
&lt;span class="c1"&gt;//#define LATCH (1193180/HZ)，用此设置后时钟中断为每10ms一次&lt;/span&gt;
    &lt;span class="n"&gt;outb_p&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LATCH&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xff&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x40&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="cm"&gt;/* LSB */&lt;/span&gt;
    &lt;span class="n"&gt;outb&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;LATCH&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mh"&gt;0x40&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="cm"&gt;/* MSB */&lt;/span&gt;
&lt;span class="c1"&gt;//后面是设置定时器的中断以及打开定时器&lt;/span&gt;
    &lt;span class="n"&gt;set_intr_gate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;timer_interrupt&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;outb&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;inb_p&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x21&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;~&lt;/span&gt;&lt;span class="mh"&gt;0x01&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mh"&gt;0x21&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;set_system_gate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mh"&gt;0x80&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;system_call&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//备注：&lt;/span&gt;
&lt;span class="c1"&gt;//定时器有三个锁存器，他们各有其则，锁存器0用于维护系统时钟，地址为0x40&lt;/span&gt;
&lt;span class="c1"&gt;//锁存器1用于周期性的向DMA发送数据信号，供存储器刷新用，地址为0x41&lt;/span&gt;
&lt;span class="c1"&gt;//锁存器2用于扬声器发出声音，地址为0x42,因此这里向0x40设定值&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;INIT_TASK&lt;/code&gt;宏定义，其实就是0号任务，看起来比较混乱，其实就是初始化task_struct结构体&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#define INIT_TASK \&lt;/span&gt;
&lt;span class="c1"&gt;//0表示可运行的，15表示运行时间片，15表示运行优化级&lt;/span&gt;
&lt;span class="cm"&gt;/* state etc */&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; \
&lt;span class="c1"&gt;//0表示没有信号，{{}}信号处理句柄设为0，0表示不屏蔽信号&lt;/span&gt;
&lt;span class="cm"&gt;/* signals */&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,{{},},&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="c1"&gt;//初始化信号设置&lt;/span&gt;
&lt;span class="c1"&gt;//将exit_code以及start_code,end_code,end_data,brk,start_stack均设为0&lt;/span&gt;
&lt;span class="cm"&gt;/* ec,brk... */&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; \
&lt;span class="c1"&gt;//0表示进程号，-1表示父进程，后面三个0表示,pgrp,session,leader&lt;/span&gt;
&lt;span class="cm"&gt;/* pid etc.. */&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; \
&lt;span class="c1"&gt;//设置进程的这6个成员unsigned short uid,euid,suid; unsigned short gid,egid,sgid;&lt;/span&gt;
&lt;span class="cm"&gt;/* uid etc */&lt;/span&gt;   &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; \
&lt;span class="c1"&gt;//设置进程的报警定时器以及5个时间函数&lt;/span&gt;
&lt;span class="cm"&gt;/* alarm */&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; \
&lt;span class="c1"&gt;//表明该进程未使用协处理器&lt;/span&gt;
&lt;span class="cm"&gt;/* math */&lt;/span&gt;  &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; \
&lt;span class="cm"&gt;/* fs info */&lt;/span&gt;   &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mo"&gt;0022&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; \
&lt;span class="cm"&gt;/* filp */&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,},&lt;/span&gt; \
&lt;span class="c1"&gt;//这里就是很关键的一部份，表始初始化一个局部LDT表，即第一个任务的&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; \
        &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; \
&lt;span class="cm"&gt;/* ldt */&lt;/span&gt;   &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mh"&gt;0x9f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mh"&gt;0xc0fa00&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; \
        &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mh"&gt;0x9f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mh"&gt;0xc0f200&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; \
    &lt;span class="p"&gt;},&lt;/span&gt; \
&lt;span class="c1"&gt;//第一个任务的任务状态表，跟踪struct tss_struct可以知道其详细意义&lt;/span&gt;
&lt;span class="cm"&gt;/*tss*/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;PAGE_SIZE&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;init_task&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mh"&gt;0x10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;pg_dir&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;\
     &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; \
     &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mh"&gt;0x17&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mh"&gt;0x17&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mh"&gt;0x17&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mh"&gt;0x17&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mh"&gt;0x17&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mh"&gt;0x17&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; \
     &lt;span class="n"&gt;_LDT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="mh"&gt;0x80000000&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; \
        &lt;span class="p"&gt;{}&lt;/span&gt; \
    &lt;span class="p"&gt;},&lt;/span&gt; \
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;到这了，也差不多了，额外的部份再看看第一个任务的LDT表与TSS表，由上面可知0号任务的LDT的代码段与数据段分别为{0x9f,0xc0fa00}与{0x9f,0xc0f200},根据保护模式下的定义，可以代码段的段基址为0，段限长为640KB,段属性为存在于内存中、特权级为3，代码段，同理分析得数据段的段基址为0，段限长为640KB,段属性为存在于内存中，特权级为3，数据段&lt;/p&gt;
&lt;p&gt;第一个任务的状态表，提一下吧&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;tss_struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt;    &lt;span class="n"&gt;back_link&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="cm"&gt;/* 16 high bits zero */&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt;    &lt;span class="n"&gt;esp0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt;    &lt;span class="n"&gt;ss0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/* 16 high bits zero */&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt;    &lt;span class="n"&gt;esp1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt;    &lt;span class="n"&gt;ss1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/* 16 high bits zero */&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt;    &lt;span class="n"&gt;esp2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt;    &lt;span class="n"&gt;ss2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/* 16 high bits zero */&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt;    &lt;span class="n"&gt;cr3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt;    &lt;span class="n"&gt;eip&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt;    &lt;span class="n"&gt;eflags&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt;    &lt;span class="n"&gt;eax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;ecx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;edx&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;ebx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt;    &lt;span class="n"&gt;esp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt;    &lt;span class="n"&gt;ebp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt;    &lt;span class="n"&gt;esi&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt;    &lt;span class="n"&gt;edi&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt;    &lt;span class="n"&gt;es&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="cm"&gt;/* 16 high bits zero */&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt;    &lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="cm"&gt;/* 16 high bits zero */&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt;    &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="cm"&gt;/* 16 high bits zero */&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt;    &lt;span class="n"&gt;ds&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="cm"&gt;/* 16 high bits zero */&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt;    &lt;span class="n"&gt;fs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="cm"&gt;/* 16 high bits zero */&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt;    &lt;span class="n"&gt;gs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="cm"&gt;/* 16 high bits zero */&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt;    &lt;span class="n"&gt;ldt&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/* 16 high bits zero */&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt;    &lt;span class="n"&gt;trace_bitmap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="cm"&gt;/* bits: trace 0, bitmap 16-31 */&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;i387_struct&lt;/span&gt; &lt;span class="n"&gt;i387&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;根据这个表可以看到的是任务0的内核态堆栈指针esp0=PAGE_SIZE+(long)&amp;amp;init_task,即第一个PCB块(task_struct)的顶部空间，PAGE_SIZE=4k,ss0=0x10,0x10查一下head.s你就会发现是gdt的第一个描述符，即内核代码段，后面还有几个是对数据段寄存器的定义以及ldt的定义&lt;/p&gt;</summary><category term="Linux汇总"></category></entry><entry><title>Assert(断言)实现机制剖析</title><link href="http://www.yanyulin.info/pages/2013/11/assert.html" rel="alternate"></link><updated>2013-11-18T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2013-11-18:pages/2013/11/assert.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;断言(assert)的作用是用来判断程序运行的正确性，确保程序运行的行为与我们理解的一致。其调用形式为assert(logic expression),如果逻辑表达式为假，则调用abort()终止程序的运行。&lt;/p&gt;
&lt;p&gt;查看MSDN帮助文档，可以得到assert的解释信息如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;ANSI&lt;/span&gt; &lt;span class="n"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;macro&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;typically&lt;/span&gt; &lt;span class="n"&gt;used&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;identify&lt;/span&gt; &lt;span class="n"&gt;logic&lt;/span&gt; &lt;span class="n"&gt;errors&lt;/span&gt; &lt;span class="n"&gt;during&lt;/span&gt; &lt;span class="n"&gt;program&lt;/span&gt; &lt;span class="n"&gt;development&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
&lt;span class="n"&gt;by&lt;/span&gt; &lt;span class="n"&gt;implementing&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;expression&lt;/span&gt; &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt; &lt;span class="n"&gt;only&lt;/span&gt; &lt;span class="n"&gt;when&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;program&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; 
&lt;span class="n"&gt;operating&lt;/span&gt; &lt;span class="n"&gt;incorrectly&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;After&lt;/span&gt; &lt;span class="n"&gt;debugging&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;complete&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;assertion&lt;/span&gt; &lt;span class="n"&gt;checking&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="n"&gt;turned&lt;/span&gt; &lt;span class="n"&gt;off&lt;/span&gt; 
&lt;span class="n"&gt;without&lt;/span&gt; &lt;span class="n"&gt;modifying&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;source&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="n"&gt;by&lt;/span&gt; &lt;span class="n"&gt;defining&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;identifier&lt;/span&gt; &lt;span class="n"&gt;NDEBUG&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;NDEBUG&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="n"&gt;defined&lt;/span&gt; 
&lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="n"&gt;command&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="n"&gt;option&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="n"&gt;directive&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;If&lt;/span&gt; &lt;span class="n"&gt;NDEBUG&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;defined&lt;/span&gt; &lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
&lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;directive&lt;/span&gt; &lt;span class="n"&gt;must&lt;/span&gt; &lt;span class="n"&gt;appear&lt;/span&gt; &lt;span class="n"&gt;before&lt;/span&gt; &lt;span class="n"&gt;ASSERT&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;included&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;翻译过来大概意思就是assert是通过判断其参数的真假来标识程序的逻辑错误，调试结束后可以通过定义NDEBUG来关闭assert断言。&lt;/p&gt;
&lt;p&gt;查看include/assert.h头文件可以得到assert相关的宏写义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#ifdef  NDEBUG&lt;/span&gt;
&lt;span class="cp"&gt;#define assert(exp)     ((void)0)&lt;/span&gt;
&lt;span class="cp"&gt;#else&lt;/span&gt;
&lt;span class="cp"&gt;#ifdef  __cplusplus&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;span class="n"&gt;_CRTIMP&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="kr"&gt;__cdecl&lt;/span&gt; &lt;span class="n"&gt;_assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cp"&gt;#ifdef  __cplusplus&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;span class="cp"&gt;#define assert(exp) (void)( (exp) || (_assert(#exp, __FILE__, __LINE__), 0) )&lt;/span&gt;
&lt;span class="cp"&gt;#endif  &lt;/span&gt;&lt;span class="cm"&gt;/* NDEBUG */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解释：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#ifdef NDEBUG &lt;/span&gt;
&lt;span class="c1"&gt;//当调试完成后，如果定义了NDEBUG,关闭断言，优化生成的代码&lt;/span&gt;
&lt;span class="cp"&gt;#define assert(_Expression)  ((void)0)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来的代码意思是定义如下函数（此函数用于打印出出错信息）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;_wassert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_In_z_&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;wchar_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;_Message&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
         &lt;span class="n"&gt;_In_z_&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;wchar_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;_File&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
         &lt;span class="n"&gt;_In_&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="n"&gt;_Line&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有兴趣的可以在assert.c中看到其实现，函数先要把错误的报告模式以及程序的类型(控制台程序还是GUI程序)决定assert是向标准错误输出打印还是以消息框形式出现，最后调用了abort（）函数来终止程序的运行。 对于extern “C” 有时间再解释，好了，到最后，终于看到了assert的宏定义了&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#define assert(_Expression) &lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_Expression&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_wassert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_CRT_WIDE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;_Expression&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; 
                                       &lt;span class="n"&gt;_CRT_WIDE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;__FILE__&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; 
                                       &lt;span class="n"&gt;__LINE__&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                                       &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
      &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;asset断言后返回的结果始终是void(1)/void(0),原因就在于逗号表达式。
Assert断言在程序的作用&lt;/p&gt;
&lt;p&gt;Assert的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="vi"&gt;#include&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;iostream&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="vi"&gt;#include&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;assert.h&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nx"&gt;using&lt;/span&gt; &lt;span class="nx"&gt;namespace&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="bp"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nx"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解释：因为tmp=0,tmp==1为false,故程序运行的时候传给assert宏的参数为false,因此调用的结果是先向stderr打印一条出错信息，然后通过调用 abort 来终止程序运行。如果改成tmp=1,则程序完全正常运行。 如里在程序中想关闭assert宏断言，可以如下defnie NDEBUG&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="vi"&gt;#include&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;iostream&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="vi"&gt;#define&lt;/span&gt; &lt;span class="nx"&gt;NDEBUG&lt;/span&gt;
&lt;span class="vi"&gt;#include&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;assert.h&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nx"&gt;using&lt;/span&gt; &lt;span class="nx"&gt;namespace&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="bp"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nx"&gt;assert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你会发现即出tmp=0,也不会再出现断言信息，解释请看顶部&lt;/p&gt;
&lt;p&gt;作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;断言可以用来检查传给函数参数的合法性&lt;/li&gt;
&lt;li&gt;一个断言一般只用来检查一个条件，便于分析程序&lt;/li&gt;
&lt;li&gt;断言前后最好空一格[编程风格的问题，按你自已的喜好，适合自已就最好]&lt;/li&gt;
&lt;li&gt;断言只是用来检查程序的逻辑正确性，不能代替条件替换&lt;/li&gt;
&lt;li&gt;断言比printf语句这种形式的打印好使&lt;/li&gt;
&lt;li&gt;断言参数可以是函数调用,但是函数返回值要是真假,如assert(sort()),解释看上面源码分析&lt;/li&gt;
&lt;/ol&gt;</summary><category term="C++学习"></category></entry><entry><title>被人误解的SIZEOF</title><link href="http://www.yanyulin.info/pages/2013/11/sizeof.html" rel="alternate"></link><updated>2013-11-18T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2013-11-18:pages/2013/11/sizeof.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;sizeof是一个函数吗?&lt;/p&gt;
&lt;p&gt;sizeof与strlen的区别?&lt;/p&gt;
&lt;p&gt;sizeof(int)(*p)的值是多少?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//是多少?&lt;/span&gt;
&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="c1"&gt;//是多少？&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//值是多少&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;1:对于第一个问题，sizeof 不是一个函数，而是一个语言内置的关键字，不信你试试sizeof 4与sizeof(int),打印结果均是4，如果是函数，肯定要加上括号，即然没加括号，那么sizeof是啥呢:),如果还不信，你可以找任何一本C++/C程序语言书查查，sizeof是32个关键字中的一个，如果没有，你就换本书吧:)&lt;/p&gt;
&lt;p&gt;即然是关键字为什么又要加括号呢？你可以试一下sizeof int 与&lt;code&gt;sizeof(int)&lt;/code&gt;,第一个会编译通不过，而第二个确能编译通过，想想C/C++语言的规定，int前只能加signed.unsigned,auto,const,volative,用来修饰变量的存储方式，可没有提到前面可以加sizeof呦，如果前面加sizeof表示是什么存储方式呢:)&lt;/p&gt;
&lt;p&gt;2:sizeof是关键字，strlen是一个标准C语言库函数，用来求取字符串的长度，&lt;code&gt;char *str="abacd"&lt;/code&gt;,&lt;code&gt;sizeof str&lt;/code&gt;与&lt;code&gt;strlen（str)&lt;/code&gt;，编译一下，看看结果就知道了:),一个结果是4,一个结果是5，结果为4是因为一个指针占4字节，结果为5是因为串长abacd刚好5个字符，不作解释&lt;/p&gt;
&lt;p&gt;3:&lt;code&gt;sizeof(int)(*p)&lt;/code&gt;的值是多少?这个其借助1，已经分析的很详细了，其实就是取*p的值，对其转化成int类型的数据，再测量譔数据占的内存字节数，显然一个int型数据占4个字节&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="c1"&gt;//下面的结果是多少?&lt;/span&gt;
&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;测量结果是多少呢？这个结果是40，sizeof在此处测量的是一个数组的大小&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;&lt;span class="err"&gt;是多少&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;细心的人会发现a[10]已经越界访问了，此处使用sizeof并不会报错，因为越界错误是运行时异常，编译器不作检查，此时a[10]编译器认为就是数组里的一个整形变量，结果当然也是4&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//值是多少?&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面这个输出的值是多少呢？你可以写个程序试一下，结果是4，为什么呢，是因为C/C++语言规定函数无法以数组作为参数或者返回值，上面的函数在实际的编译过程中会被转化成&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="n"&gt;cout&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//值是多少?&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因为a是一个指向整形的指针，结果为4也是很显然的&lt;/p&gt;</summary><category term="C++学习"></category></entry><entry><title>String StringBuffer StringBuilder的区别分析</title><link href="http://www.yanyulin.info/pages/2013/07/string.html" rel="alternate"></link><updated>2013-07-31T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2013-07-31:pages/2013/07/string.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;这是一道很常见的面试题目，至少我遇到过String/StringBuffer/StringBuilder的区别：String是不可变的对象(final)类型，每一次对String对象的更改均是生成一个新的String对象，原有的对象不会改变，相比之下StringBuffer与StringBuilder均是可更改的对象，效率要大于String,两者之间的区别在于StringBuffer适用于多线程，是线程安全的，而StringBuiler是JDK5.0后出来的，专门针对单线程，效率上要高于StringBuffer。&lt;/p&gt;
&lt;p&gt;String测试的源代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//生成一个字符串对象&lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;//让两个tmp指向同一个字符串&lt;/span&gt;
&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;//对字符串进行重新赋值，如果str是可以更改的，那么最终的结果就是tmp与str的值还是一样的&lt;/span&gt;
&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;//将结果打印出来&lt;/span&gt;
&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//test&lt;/span&gt;
&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//abc&lt;/span&gt;
&lt;span class="c1"&gt;//时间测试，待会与后面结果对比&lt;/span&gt;
&lt;span class="n"&gt;long&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;1000000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;//平均时间会运行好久好久的，真的，你可以试试，有几分钟&lt;/span&gt;
&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的代码很显然了吧，如果String是可变对象的话，那么str与tmp的结果应该是一样的，因为指向了同一片空间，但最后结果不一样，是因为String指向的空间是一个final类型，不可更改的，执行str=”test”,实际上是又重新申请了空间存放test，然后str指向了”test”这片空间，而tmp不变，最后的时间测试中，由于每次都是由str+”a”构造出一个新的对象，然后将str指向这个新的对象，期间str原来指向的空间会由GC回收，因此会很费时的。&lt;/p&gt;
&lt;p&gt;看看String类实现的部份源码&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;final&lt;/span&gt; &lt;span class="nb"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;String&lt;/span&gt;
&lt;span class="nx"&gt;implements&lt;/span&gt; &lt;span class="nx"&gt;java.io.Serializable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;Comparable&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;CharSequence&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="cm"&gt;/** 存放字符串的空间，看看前面的final,应该就明白了吧，修饰的内容是不可更改的*/&lt;/span&gt;
&lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="nf"&gt;final&lt;/span&gt; &lt;span class="nx"&gt;char&lt;/span&gt; &lt;span class="nb"&gt;value&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;;

/**偏移位置，第一个字符*/
private final int offset;

/**字符个数*/
private final int count;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你也会发现，里面用来存储字符串的是一个char型的数组value,看看char的前面的那个final,应该明白了吧：）&lt;/p&gt;
&lt;p&gt;StringBuffer的测试源代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//生成一个StringBuffer对象,并在里面存放abc&lt;/span&gt;
&lt;span class="n"&gt;StringBuffer&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StringBuffer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//tmp也指向这个StringBuffer对象&lt;/span&gt;
&lt;span class="n"&gt;StringBuffer&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;//对字符串进行重新赋值，如果str是可以更改的，那么最终的结果就是tmp与str的值还是一样的&lt;/span&gt;
&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//将结果打印出来&lt;/span&gt;
&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//abcabc&lt;/span&gt;
&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//abcabc&lt;/span&gt;
&lt;span class="c1"&gt;//时间测试，待会与后面结果对比&lt;/span&gt;
&lt;span class="n"&gt;long&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;1000000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//平均时间在63ms左右&lt;/span&gt;
&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的代码也是很显然的吗，由于操作的始终是同一个对象，同一片内存空间，因此tmp与str的值是一样的，在测试时间时，由于避免了内存的释放与回收(不是绝对的避免，当内存不足以存放数据时，又重新分配一片大点的空间，总的来说就是减少的内存的释放与回收)，因此时间大大减少，效率提高了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;final&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;StringBuffer&lt;/span&gt; &lt;span class="n"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;AbstractStringBuilder&lt;/span&gt;
 &lt;span class="n"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Serializable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CharSequence&lt;/span&gt;
 &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;serialVersionUID&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3388685877147921107L&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * 可以看出会有16B的默认空间 &lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
  &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;StringBuffer&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;super&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从这里可以看出，如果什么都不存放的话，StringBuffer会有16字节的默认空间&lt;/p&gt;
&lt;p&gt;看看StringBuffer的父类，更清楚:)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;abstract&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;AbstractStringBuilder&lt;/span&gt; &lt;span class="n"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Appendable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CharSequence&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; *这个value就是用来存放字符串的，默认情况下就是16B的空间，没有final吧:)&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;[];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;看了这些，你也应该知道String与StringBuffer的区别，还有一点就是StringBuffer是线程安全的，体现在哪呢，看看源代码吧:)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;synchronized&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;length&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;synchronized&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;capacity&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;synchronized&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;ensureCapacity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;minimumCapacity&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;minimumCapacity&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;expandCapacity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;minimumCapacity&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面只是部份方法，你可以看到的是大部份的方法都含有一个synchronized关键字，这个关键字的作用就是用来进行线程同步的，因此是多线程安全的。
StringBuilder的测试源代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//生成一个StringBuilder对象,并在里面存放abc&lt;/span&gt;
&lt;span class="n"&gt;StringBuilder&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StringBuilder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//tmp也指向这个StringBuffer对象&lt;/span&gt;
&lt;span class="n"&gt;StringBuilder&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;//对字符串进行重新赋值，如果str是可以更改的，那么最终的结果就是tmp与str的值还是一样的&lt;/span&gt;
&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//将结果打印出来&lt;/span&gt;
&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//abcabc&lt;/span&gt;
&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="c1"&gt;//abcabc&lt;/span&gt;
&lt;span class="c1"&gt;//时间测试，待会与后面结果对比&lt;/span&gt;
&lt;span class="n"&gt;long&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mh"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mh"&gt;1000000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//平均时间在36左右&lt;/span&gt;
&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;currentTimeMillis&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的代码也是类似的，说明了StringBuilder与StringBuffer类似，但比StringBuffer的效率更改，这是为什么呢，看看源代码就知道了:)
源代码中StringBuffer与StringBuilder继承自同一个父类，代码极奇相似，只是StringBuilder各个函数少了synchonized关键字，这也就说明了StringBuilder不是线程安全的，即然有了synchronized关键字，那么代码每次运行的时候均需要锁住该对象，以避免其他对象调用该方法，不管是单线程还是多线程，因此这需要一定的开销，因此StringBuiler的效率要高于StringBuffer:)&lt;/p&gt;</summary><category term="Java"></category></entry></feed>