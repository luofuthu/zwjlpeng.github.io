<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>烟雨林</title><link href="http://www.yanyulin.info/" rel="alternate"></link><link href="http://www.yanyulin.info/feeds/jing-pin-shu-ji.atom.xml" rel="self"></link><id>http://www.yanyulin.info/</id><updated>2013-11-23T00:00:00+08:00</updated><entry><title>Effective C++(编程的50个细节)</title><link href="http://www.yanyulin.info/pages/2013/11/effective.html" rel="alternate"></link><updated>2013-11-23T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2013-11-23:pages/2013/11/effective.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;&lt;code&gt;Effective C++(编程的50个细节)&lt;/code&gt;着重讲解了编写C++程序应该注意的50个细节问题，书中的每一条准则描述了一个编写出更好的C++的方式，每一个条款的背后都有具体范例支持，书中讲的都是C++的编程技巧和注意事项，很多都是自己平时不太注意但又很重要的内容，绝对经典，作者Scott Meyers是全世界最知名的C++软件开发专家之一。&lt;/p&gt;
&lt;p&gt;电子书PDF格式下载:&lt;a href="http://yunpan.cn/QUdi9Cq7G6RAZ" target="_blank" title="《Effective C++》"&gt;点这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1、从C转向C++&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;条款1:尽量用CONST和INLINE而不用#DEFINE&lt;/p&gt;
&lt;p&gt;条款2:尽量用&lt;IOSTREAM&gt;而不用&lt;STDIO.H&gt;&lt;/p&gt;
&lt;p&gt;条款3:尽量用NEW和DELETE而不用MALLOC和FREE&lt;/p&gt;
&lt;p&gt;条款4:尽量使用C++风格的注释&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、内存管理&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;条款5:对应的NEW和DELETE要采用相同的形式&lt;/p&gt;
&lt;p&gt;条款6:析构函数里对指针成员调用DELETE&lt;/p&gt;
&lt;p&gt;条款7:预先准备好内存不够的情况&lt;/p&gt;
&lt;p&gt;条款8:写OPERATOR NEW与OPERATOR DELETE要遵循常规&lt;/p&gt;
&lt;p&gt;条款9:避免隐藏标准形式的NEW&lt;/p&gt;
&lt;p&gt;条款10:如果写了OPERATOR NEW就要同时写OPERATOR DELETE&lt;/p&gt;
&lt;p&gt;条款11:为需要动态分配内存的类声明一个拷贝构造函数和一个赋值函数&lt;/p&gt;
&lt;p&gt;条款12:尽量使用初始化而不要在构造函数里赋值&lt;/p&gt;
&lt;p&gt;条款13:初始化列表中成员列出顺序和它们在类中的声明顺序相同&lt;/p&gt;
&lt;p&gt;条款14:确定基类有虚析构函数&lt;/p&gt;
&lt;p&gt;条款15:让OPERATOR=返回*THIS的引用&lt;/p&gt;
&lt;p&gt;条款16:在OPERATOR=中对所有数据成员赋值&lt;/p&gt;
&lt;p&gt;条款17:在OPERATOR=中检查给自已赋值的情况&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3、类和函数:设计与声明&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;条款18:争取使类的接口完整并且最小&lt;/p&gt;
&lt;p&gt;条款19:分清成员函数，非成员函数和友元函数&lt;/p&gt;
&lt;p&gt;条款20:避免PUBLIC接口出现数据成员&lt;/p&gt;
&lt;p&gt;条款21:尽可能使用CONST&lt;/p&gt;
&lt;p&gt;条款22:尽量用传引用而不用传值&lt;/p&gt;
&lt;p&gt;条款23:必须返回一个对象时不要试图返回一个引用&lt;/p&gt;
&lt;p&gt;条款24:在函数重载与设定参数默认值间慎重选择&lt;/p&gt;
&lt;p&gt;条款25:避免对指针与数字类型的重载&lt;/p&gt;
&lt;p&gt;条款26:当心潜在的二义性&lt;/p&gt;
&lt;p&gt;条款27:如果不想使用隐式生成的函数要显示的禁止它&lt;/p&gt;
&lt;p&gt;条款28:划分全局名字空间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4、类和函数：实现&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;条款29:避免返回内部数据的句柄&lt;/p&gt;
&lt;p&gt;条款30:避免这样的成员函数，其返回值是指向成员的非CONST指针或引用&lt;/p&gt;
&lt;p&gt;条款31:千万不要返回局部对象的引用，也不要返回函数内部用NEW初始化的指针&lt;/p&gt;
&lt;p&gt;条款32:尽可能推迟变量的定义&lt;/p&gt;
&lt;p&gt;条款33:明智的使用INLINE&lt;/p&gt;
&lt;p&gt;条款34:将文件间的编译依赖性阡至最低&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;5、继承与面向对象设计&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;条款35:使公有继承体现是一个的函义&lt;/p&gt;
&lt;p&gt;条款36:区分接口继承与实现继承&lt;/p&gt;
&lt;p&gt;条款37:绝不要重新定义继承而来的非虚函数&lt;/p&gt;
&lt;p&gt;条款38:绝不要重新定义继承而来的缺省参数值&lt;/p&gt;
&lt;p&gt;条款39:避免向下转换继承层次&lt;/p&gt;
&lt;p&gt;条款40:通过分层来体现有一个和用...来实现&lt;/p&gt;
&lt;p&gt;条款41:区分继承和模板&lt;/p&gt;
&lt;p&gt;条款42:明智的使用私有继承&lt;/p&gt;
&lt;p&gt;条款43:明智的使用多继承&lt;/p&gt;
&lt;p&gt;条款44:说你想说的，理解你说的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;6、杂项&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;条款45:弄清C++在幕后为你所写、所调用的函数&lt;/p&gt;
&lt;p&gt;条款46:宁可编译与链接时出错，也不要运行时出错&lt;/p&gt;
&lt;p&gt;条款47:确保非局部静态对象在使用前被初始化&lt;/p&gt;
&lt;p&gt;条款48:重视编译器警告&lt;/p&gt;
&lt;p&gt;条款49:熟悉标准库&lt;/p&gt;
&lt;p&gt;条款50:提高对C++的认识&lt;/p&gt;
&lt;/blockquote&gt;</summary><category term="C++书库"></category></entry><entry><title>STL源码剖析(候捷译)</title><link href="http://www.yanyulin.info/pages/2013/11/stlOrigin.html" rel="alternate"></link><updated>2013-11-21T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2013-11-21:pages/2013/11/stlOrigin.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;STL源码剖析 PDF格式下载:&lt;a href="http://yunpan.cn/QUj5p6EIPZH9y" target="_blank" title="《STL源码剖析》"&gt;点这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;STL源码剖析此书是一本不可多得的好书，大师的精典之作，大多数程序员只知道集合类非常好用，只需要向集合类中填加元素，不用担心空间的开设，以及空间的回收，也不用考虑集合类的效率，更重要的是集合类还给我们提供了各种各样的函数，但是知其所以然而不知其因为然，这样的程序员是不合格的，《STL源码剖析》很好的给我们讲解了集合类的底层实现，以及泛型算法。&lt;/p&gt;
&lt;p&gt;STL源码剖析&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;前言&lt;/p&gt;
&lt;p&gt;第1章STL概论与版本简介&lt;/p&gt;
&lt;p&gt;第2章 空间配置器（allocator）&lt;/p&gt;
&lt;p&gt;第3章迭代器（iterators）概念与traits编程技法&lt;/p&gt;
&lt;p&gt;第4章 序列式容器（sequence containers）&lt;/p&gt;
&lt;p&gt;第5章 关联式容器（associattive containers）&lt;/p&gt;
&lt;p&gt;第6章 算法（algorithms）&lt;/p&gt;
&lt;p&gt;第7章 仿函数（functors，另名 函数对象function objects）&lt;/p&gt;
&lt;p&gt;第8章 配接器（adapters）&lt;/p&gt;
&lt;p&gt;附录A 参考书籍与推荐读物&lt;/p&gt;
&lt;p&gt;附录B 候捷网站（本书支持站点简介）&lt;/p&gt;
&lt;p&gt;附录C STLPort 的移植经验（by孟岩&lt;/p&gt;
&lt;/blockquote&gt;</summary><category term="C++书库"></category></entry><entry><title>深度探索C++对象模型</title><link href="http://www.yanyulin.info/pages/2013/11/objectModel.html" rel="alternate"></link><updated>2013-11-18T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2013-11-18:pages/2013/11/objectModel.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;电子书PDF格式下载:&lt;a href="http://yunpan.cn/QUK3HwIaW6tu2" target="_blank" title="《深度探索C++对象模型》"&gt;点这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第0章 导读（译者的话）&lt;/p&gt;
&lt;p&gt;第1章 关于对象（Object Lessons）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.1 C++对象模型（The C++ Object Model）&lt;/p&gt;
&lt;p&gt;1.2 关键词所带来的差异（A Keyword Distinction）&lt;/p&gt;
&lt;p&gt;1.3 对象的差异（An Object Distinction）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第2章 构造函数语意学（The Semantics of constructors）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2.1 Default Constructor的建构操作&lt;/p&gt;
&lt;p&gt;2.2 Copy Constructor的建构操作&lt;/p&gt;
&lt;p&gt;2.3 程序转换语意学（Program Transformation Semantics）&lt;/p&gt;
&lt;p&gt;2.4 成员们的初始化队伍（Member Initialization List）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第3章 Data语意学（The Semantics of Data）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;3.1 Data Member的绑定（The Binding of a Data Member）&lt;/p&gt;
&lt;p&gt;3.2 Data Member的布局（Data Member Layout）&lt;/p&gt;
&lt;p&gt;3.3 Data Member的存取&lt;/p&gt;
&lt;p&gt;3.4 “继承”与Data Member&lt;/p&gt;
&lt;p&gt;3.5 对象成员的效率（Object Member Efficiency）&lt;/p&gt;
&lt;p&gt;3.6 指向Data Members的指针（Pointer to Data Members）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第4章 Function语意学（The Semantics of Function）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;4.1 Member的各种调用方式&lt;/p&gt;
&lt;p&gt;4.2 Virtual Member Functions（虚拟成员函数）&lt;/p&gt;
&lt;p&gt;4.3 函数的效能&lt;/p&gt;
&lt;p&gt;4.4 指向Member Functions的指针（Pointer-to-Member Functions）&lt;/p&gt;
&lt;p&gt;4.5 Inline Functions&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第5章 构造、解构、拷贝 语意学（Semantics of Construction，Destruction，and Copy）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;5.1 无继承情况下的对象构造&lt;/p&gt;
&lt;p&gt;5.2 继承体系下的对象构造&lt;/p&gt;
&lt;p&gt;5.3 对象复制语意学（Object Copy Semantics）&lt;/p&gt;
&lt;p&gt;5.4 对象的功能（Object Efficiency）&lt;/p&gt;
&lt;p&gt;5.5 解构语意学（Semantics of Destruction）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第6章 执行期语意学（Runting Semantics）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;6.1 对象的构造和解构（Object Construction and Destruction）&lt;/p&gt;
&lt;p&gt;6.2 new和delete运算符&lt;/p&gt;
&lt;p&gt;6.3 临时性对象（Temporary Objects）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第7章 站在对象模型的类端（On the Cusp of the Object Model）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;7.1 Template&lt;/p&gt;
&lt;p&gt;7.2 异常处理（Exception Handling）&lt;/p&gt;
&lt;p&gt;7.3 执行期类型识别（Runtime Type Identification，RTTI）&lt;/p&gt;
&lt;p&gt;7.4 效率有了，弹性呢？&lt;/p&gt;
&lt;/blockquote&gt;</summary><category term="C++书库"></category></entry></feed>