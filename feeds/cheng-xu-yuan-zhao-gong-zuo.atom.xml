<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>烟雨林</title><link href="http://www.yanyulin.info/" rel="alternate"></link><link href="http://www.yanyulin.info/feeds/cheng-xu-yuan-zhao-gong-zuo.atom.xml" rel="self"></link><id>http://www.yanyulin.info/</id><updated>2013-12-06T00:00:00+08:00</updated><entry><title>阿里巴巴2014年校招笔试题(研发)</title><link href="http://www.yanyulin.info/pages/2013/12/alibaba_2014_A.html" rel="alternate"></link><updated>2013-12-06T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2013-12-06:pages/2013/12/alibaba_2014_A.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;如有错误，或更加精简的方法，请留言，我会更正，以方便更多的人&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一部分 单选题&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;1 一次内存访、SSD硬盘访问和SATA硬盘随机访问的时间分别约是（）。&lt;/p&gt;
&lt;p&gt;A、几微秒，几毫秒，几十毫秒        B、几微秒，几十微秒，几十毫秒 &lt;/p&gt;
&lt;p&gt;C、几十纳秒，几十微秒，几十毫秒  D、几十纳秒，几十微秒，十几毫秒    &lt;/p&gt;
&lt;p&gt;2 8进制数256，转换成7进制数是（）&lt;/p&gt;
&lt;p&gt;A、356     B、346   C、338    D、336    &lt;/p&gt;
&lt;p&gt;3 某网络的IP地址空间为&lt;code&gt;192.168.5.0/24&lt;/code&gt;。采用定长子网划分，子网掩码为&lt;code&gt;255.255.255.248&lt;/code&gt;，则该网络的最大子网个数、每个子网内的最大可分配地址个数各为()&lt;/p&gt;
&lt;p&gt;A、32，6    B、32，8  C、8，32  D、8，30    &lt;/p&gt;
&lt;p&gt;4 以下关于链式存储结构说法错误的是()&lt;/p&gt;
&lt;p&gt;A、比顺序存储结构的存储密度小     B、每个节点是由数据域和指针域组成 &lt;/p&gt;
&lt;p&gt;C、查找节点时链式存储比顺序存储块  D、逻辑上不相邻的节点物理上可能相邻   &lt;/p&gt;
&lt;p&gt;5 假定一个二维数组的定义语句为&lt;code&gt;int a[3][4]={{3,4},{2,8,6}}&lt;/code&gt;;，则元 素&lt;code&gt;a[1][2]&lt;/code&gt;的值为()&lt;/p&gt;
&lt;p&gt;A、2   B、4     C、6     D、8    &lt;/p&gt;
&lt;p&gt;6 下面函数的功能是()&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
 &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="n"&gt;While&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
 &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A、求字符串的长度     B、复制一个字符串   C、计算字符串的位(bit)数   D、求字符串存放的位置    &lt;/p&gt;
&lt;p&gt;7 判断有向图是否存在回路，利用()方法最佳&lt;/p&gt;
&lt;p&gt;A、求关键路径   B、求最短路径     C、拓扑排序  D、广度优先遍历    &lt;/p&gt;
&lt;p&gt;8 依次读入数据元素序列&lt;code&gt;{a,b,c,d,e,f,g}&lt;/code&gt;进栈，元素进栈或出栈顺序是未知的，下列序列中，不可能成为栈空时弹出的元素构成序列的有()&lt;/p&gt;
&lt;p&gt;A 、{d,e,c,f,b,g,a}    B、{f,e,g,d,a,c,b}   C、{e,f,d,g,c,b,a}   D、{c,d,b,e,f,a,g}   &lt;/p&gt;
&lt;p&gt;9 下列有关图的遍历说法中，不正确的是()
 
  A、图的遍历必须用递归实现     B、基本遍历算法有两种：深度遍历和广度遍历 &lt;/p&gt;
&lt;p&gt;C、有向图和无向图都可以进行遍历操作  D、图的遍历算法可以执行在有回路的图上  &lt;/p&gt;
&lt;p&gt;10 在16位机器上跑下列foo函数的结果是()&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt; 
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;65536&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;65535&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A、-1，65535  B、0，65535  C、-1，-1     D、0，-1&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下每题3分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;11 有一段年代久远的C++代码，内部逻辑复杂。现在需要利用其实现一个新的需求，假定有以下可行的方案，应当优先选择()&lt;/p&gt;
&lt;p&gt;A、修改老代码接口，满足新的需求   &lt;/p&gt;
&lt;p&gt;B、在这段代码之外写一段代码，调用该代码的一些模块，完成新功能需求      &lt;/p&gt;
&lt;p&gt;C、修改老代码的内部逻辑，满足新的需求    &lt;/p&gt;
&lt;p&gt;D、将老代码抛弃，自己重新实现类似的逻辑  &lt;/p&gt;
&lt;p&gt;12 在5个页框上使用LRU页面替换算法。当页框初始为空时，引用序列为0、1、7、8、6、2、3、7、2、9、8、1、0、2，系统将发生()次缺页。 &lt;/p&gt;
&lt;p&gt;A、11 B、12 C、13 D、8 &lt;/p&gt;
&lt;p&gt;13 阿里巴巴有相距1500km的两机房A和B。现在有100GB数据需要通过一条FTP连接在100s的时间内从A传输到B。已知FTP连接建立在TCP协议之上，而TCP协议通过ACK来确认每个数据包是否正确传送。网络信号传输速度为
2*108m/s，假设机房间带宽足够高，那么A节点的发送缓冲区可以设置为最小()&lt;/p&gt;
&lt;p&gt;A、6MB  B、12 MB  C、18 MB  D、24 MB  &lt;/p&gt;
&lt;p&gt;14 有3个节点的二叉树可能有()种 &lt;/p&gt;
&lt;p&gt;A、12 B、13 C、5  D、15 &lt;/p&gt;
&lt;p&gt;15 设某文件经内排序后得到100个初始归并段（初始顺串），若使用多路归并排序算法，且要求三趟归并完成排序，问归并路数最少为()&lt;/p&gt;
&lt;p&gt;A、5 B、6 C、7 D、8&lt;/p&gt;
&lt;p&gt;16 一个优化的程序可以生成一n个元素集合的所有子集，那么该程序的时间复
杂度是() &lt;/p&gt;
&lt;p&gt;A、O(n!) B、O(nlogn) C、O(n2) D、O(2n) &lt;/p&gt;
&lt;p&gt;17 快速排序在已经有序的情况下效率最差，复杂度为()
 
A、O(nlogn) B、O(n2logn) C、O(n1.5) D、O(n2)&lt;/p&gt;
&lt;p&gt;18 从一副牌（52张，不含大小怪）里抽出两张牌，其中一红一黑的概率是()
 
A、25/51 B、26/51 C、1/2 D、1/3 &lt;/p&gt;
&lt;p&gt;19 有一堆石子共100枚，甲乙轮流从该堆中取石子，每次可取2、4或6枚，取得最后的石子的玩家为赢家，若甲先取，则()&lt;/p&gt;
&lt;p&gt;A、甲必胜 B、乙必胜 C、谁都无法必胜 D、不确定 &lt;/p&gt;
&lt;p&gt;20. 现有一完全的P2P共享协议。每次两个节点通讯后都能获取对方已经获取的
全部信息。现在使得系统中每个节点都知道所有节点的文件信息，共17个节点，假设只能通过多次两个对等节点之间通讯的方式，则最少需要()次通讯 &lt;/p&gt;
&lt;p&gt;A、29    B、30    C、31    D、32&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二部分  不定项选择&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;21 2-3树是一种特殊的树，它满足两个条件：(1). 每个内部结点有两个或三个子结点；(2). 所有的叶结点到根的长度相同； 如果一棵2-3树有9个叶结点，下列数量个非叶结点的2-3树可能存在的有()&lt;/p&gt;
&lt;p&gt;A、4     B、5     C、6     D、7     E、8 &lt;/p&gt;
&lt;p&gt;22 下列有关进程的说法中，()是错误的&lt;/p&gt;
&lt;p&gt;A、进程是静态的 B、进程是动态的过程  C、进程与程序是一一对应的  D、进程与作业是一一对应的 &lt;/p&gt;
&lt;p&gt;23 下列函数定义中，有语法错误的是() &lt;/p&gt;
&lt;p&gt;A、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;fun&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;B、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;fun&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;C、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;fun&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;D、&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;fun&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;24 有朋自远方来。他乘火车，轮船，汽车，飞机来的概率分别是0.3，0.2，0.1，0.4。坐各交通工具迟到的概率分别是1/4，1/3，1/12，0。下列语句中正确的是()&lt;/p&gt;
&lt;p&gt;A、如果他迟到，坐火车来的概率是0.5&lt;/p&gt;
&lt;p&gt;B、如果他准点，坐轮船或汽车的概率等于坐火车的概率&lt;/p&gt;
&lt;p&gt;C、如果他准点，那么乘飞机的概率大于等于0.5&lt;/p&gt;
&lt;p&gt;D、坐陆路（火车、汽车）交通工具准点机会比坐水路（轮船）要低&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三部分  填空与问答&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;25 文件分配表FAT是管理磁盘空间的一种数据结构，用在以连接方式存储文件的系统中记录磁盘分配和跟踪空白磁盘块。整个磁盘仅设一张FAT表，其结构如下图所示。如果文件块号为2，查找FAT序号为2的内容得知物理块2的后继物理块是5；再查FAT序号为5的内容得知物理块5的后继物理块是7；接着继续查FAT序号为7的内容为”^”，即该文件结束标志，所以该文件由物理块2、5、7组成&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2013/12/alibaba_2014_A.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/daan/alibaba_0.png"/&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;假设磁盘物理块大小为1KB，并且FAT序号以4bits为单位向上扩充空间。 请计算下列两块磁盘的FAT最少需要占用多大的存储空间？ 1) 一块540MB的硬盘 2) 一块1.2GB的硬盘&lt;/p&gt;
&lt;p&gt;26 已知如下代码，并在两个线程中同时执行f1和f2，待两个函数都返回后，a的所有可能值是哪些？ &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;f1&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt; 
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;f2&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt; 
&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;27 设计一个最优算法来查找一n个元素数组中的最大值和最小值。已知一种需要比较2n次的方法，请给一个更优的算法。请特别注意优化时间复杂度的常数。 给出该算法最坏情况下的比较次数和该算法的步骤描述。 （不用写代码，不给出比较次数的不得分）  &lt;/p&gt;
&lt;p&gt;28 已知三个升序整数数组 a[l]、b[m]和c[n]。请在三个数组中各找一个元素，使得组成的三元组距离最小。三元组的距离定义是：假设a[i]、b[j]和c[k]是一个三元组，那么距离为:distance = max (|a[i]- b[j]|, | a[i] -c[k]|, | b[j] -c[k]|)&lt;/p&gt;
&lt;p&gt;请设计一求最小三元组距离的最优算法，并分析时间复杂度（不用写代码，不分析时间复杂度的不得分）&lt;/p&gt;
&lt;p&gt;29在黑板上写下50个数字：1至50。在接下来的49轮操作中，每次做如下动作：选取两个黑板上的数字a和b，擦去，在黑板上写|b-a|。请问最有一次动作之后剩下数字可能是什么？为什么？ （不用写代码，不写原因不得分）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第四部分  JAVA选做题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1请给出下面代码的输出 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Test1&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; 
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Test1&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Test1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;Test1&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Test1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;99&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
    &lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;“构造快”&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;  
    &lt;span class="k"&gt;static&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; 
        &lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;“静态块”&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;Test1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; 
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;   &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;   &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
    &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; 
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;   &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;   &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;     &lt;span class="err"&gt;】&lt;/span&gt;
    &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt;  
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="err"&gt;…&lt;/span&gt;&lt;span class="n"&gt;strings&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;     
&lt;span class="n"&gt;Test1&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Test1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2 已知：为了保持请求的并行度，一台web应用服务器目前需要10个到一台&lt;code&gt;oracle&lt;/code&gt;的数据库连接，目前oracle数据库能够稳定承载的连接数是7000个。目前已经拥有的web应用服务器数是400台，并且web服务器以每年以300的规模在增长。 &lt;/p&gt;
&lt;p&gt;问题：目前能够才去的策略有哪些？请从原理上对这些策略为什么能够起作用进行一下分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;各位如果有更好的答案，请留言评价，方便更多的人&lt;/strong&gt;&lt;/p&gt;</summary><category term="阿里巴巴"></category></entry><entry><title>创新工场2014年校招笔试题(研发)</title><link href="http://www.yanyulin.info/pages/2013/12/cxgc_2014_A.html" rel="alternate"></link><updated>2013-12-06T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2013-12-06:pages/2013/12/cxgc_2014_A.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;如有错误，或更加精简的方法，请留言，我会更正，以方便更多的人&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选择题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1 若进栈序列为&lt;code&gt;a、b、c、d&lt;/code&gt;，进栈过程中可以出栈，那么（）不可能是一个出栈序列。&lt;/p&gt;
&lt;p&gt;A cbad     B bdca     &lt;code&gt;C adbc&lt;/code&gt;   D cdba&lt;/p&gt;
&lt;p&gt;2 完全二叉树中编号为i的结点存在右孩子，右孩子结点的编号为（）设根结点编号为1。&lt;/p&gt;
&lt;p&gt;A.2i-1      B.2i      &lt;code&gt;C.2i+1&lt;/code&gt;     D.2i+2&lt;/p&gt;
&lt;p&gt;3 下面哪种排序算法的平均时间复杂度和其他不一样：&lt;/p&gt;
&lt;p&gt;A.堆排序    B.快排     &lt;code&gt;C.插入排序&lt;/code&gt;   D.归并排序&lt;/p&gt;
&lt;p&gt;4 以下情况发生时，对程序运行速度影响最小的是：&lt;/p&gt;
&lt;p&gt;A.分支预测失败    &lt;code&gt;B.L1 Cache 失效&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;C.IO等待          D.虚拟内存page miss&lt;/p&gt;
&lt;p&gt;5 Inter-processs communication(IPC) is the transfer of data among processes. 
Which is not a typical programming technique for IPC:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A.mutex&lt;/code&gt;    B.pipe     C.socket     D.message queue&lt;/p&gt;
&lt;p&gt;6 给出这样一个函数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;calc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;calc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;计算&lt;code&gt;calc(2,7&lt;/code&gt;)的值&lt;/p&gt;
&lt;p&gt;A.25    &lt;code&gt;B.24&lt;/code&gt;   C.22    D.16&lt;/p&gt;
&lt;p&gt;7 如果我们的程序需要经常在多种算法中相互替换，我们应该选择哪种设计模式（）&lt;/p&gt;
&lt;p&gt;A 工厂方法模式     &lt;code&gt;B 策略模式&lt;/code&gt;     C 适配器模式    D 责任链模式&lt;/p&gt;
&lt;p&gt;8 关于数据库的描述错误的是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A 创建索引一定能提升查询时间&lt;/code&gt;    B 主键的数据列要简历索引&lt;/p&gt;
&lt;p&gt;C 外键的数据列要建立索引        D 常见的数据库索引有Hash索引，B-tree索引&lt;/p&gt;
&lt;p&gt;9 以下TCP原语中，哪一个是用于客户端的：&lt;/p&gt;
&lt;p&gt;A bind  B listen C &lt;code&gt;connect&lt;/code&gt;  D accept&lt;/p&gt;
&lt;p&gt;10 小冯和小崔都去参加一个workshop,这个workshop从晚上6点到8点，但是他们都只参加了一部分会议。小冯参会一小时，小崔参会半小时，那么他俩相遇的可能性有多大（）&lt;/p&gt;
&lt;p&gt;A &lt;code&gt;5/6&lt;/code&gt;   B   5/8   C 1/2   D 1/4&lt;/p&gt;
&lt;p&gt;编程题&lt;/p&gt;
&lt;p&gt;1 输入一个整数无序数组，用堆排序的方法使数组有序&lt;/p&gt;
&lt;p&gt;2 求一个正整数N的开方，要求不能用库函数&lt;code&gt;sqrt()&lt;/code&gt;，结果的精度在&lt;code&gt;0.001&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3 给定一个矩阵&lt;code&gt;int maxtrixA[m][n]&lt;/code&gt;,每行和每列都是增序的，实现一个算法去找矩阵中的某个元素&lt;code&gt;element&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;各位如果有更好的答案，请留言评价，方便更多的人&lt;/strong&gt;&lt;/p&gt;</summary><category term="创新工场"></category></entry><entry><title>美团网2014年校招笔试题(研发)</title><link href="http://www.yanyulin.info/pages/2013/12/meituan_2014_A.html" rel="alternate"></link><updated>2013-12-06T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2013-12-06:pages/2013/12/meituan_2014_A.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;如有错误，或更加精简的方法，请留言，我会更正，以方便更多的人&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、某二叉树中序序列为A,B,C,D,E,F,G。后序序列为B,D,C,A,F,G,E,则该二叉树节点的前序序列是?请写出分析&lt;code&gt;过程及结果&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2、定义一个二进制数字串的“长度”为从最右侧开始算起连续1的个数（说明，如果最右侧为0，则长度为0，如果最右侧为1，则开始数连续的1的个数作为长度）。例如&lt;code&gt;length(100011)=2,length(100000)=0,&lt;/code&gt;请分析一个随机的N位字串的“长度”的期望值是多少，注意这个长度是从最右侧算起的，比如&lt;code&gt;length(111011)=2&lt;/code&gt;,即使，字符串左边出现更长的长度&lt;/p&gt;
&lt;p&gt;3、某公司的销售专家需要拜访商家，假设本市总共有M家商家，美团派了N位销售专家来拜访本市的商家。假设专家之间互不通信，每位专家随机选择&lt;code&gt;K&lt;/code&gt;个商家。如果有多位专家拜访了一个商家，我们称之为拜访碰撞。问发生拜访碰撞的概率是多少?&lt;/p&gt;
&lt;p&gt;4、请编写一个函数，实现将一棵二叉树每一个节点的左右子节点&lt;code&gt;相互调换&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;5、美团把城市比较繁华,人流大的区域用多边形圈起来，就构成了一个商业圈，如果知道一个门店的坐标，就可以知道这个店属于哪个商业圈，坐标用以下结构体表示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;请判断一个门店是否处在一个商业圈内&lt;code&gt;boolean isInner(Point *poly,int len ,point pit)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中poly表示商圈顶点多边形坐标数组，len表示顶点数量，pit表示要判断的门店坐标&lt;/p&gt;
&lt;p&gt;1、请先说明算法思路&lt;/p&gt;
&lt;p&gt;2、请编写代码实现&lt;/p&gt;
&lt;p&gt;6、给一个浮点数序列,请实现函数计算任意连续子序列最大乘积的值&lt;/p&gt;
&lt;p&gt;例如序列：-2.5 4 0 3 0.5 8 -1 &lt;/p&gt;
&lt;p&gt;则取出的连续序列为3 0.5 8&lt;/p&gt;
&lt;p&gt;最大乘积为3&lt;em&gt;0.5&lt;/em&gt;8&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;各位如果有更好的答案，请留言评价，方便更多的人&lt;/strong&gt;&lt;/p&gt;</summary><category term="美团网"></category></entry><entry><title>2014年百度校招笔试试卷A</title><link href="http://www.yanyulin.info/pages/2013/12/baidu_2014_A.html" rel="alternate"></link><updated>2013-12-03T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2013-12-03:pages/2013/12/baidu_2014_A.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;如有错误，或更加精简的方法，请留言，我会更正，以方便更多的人&lt;/p&gt;
&lt;p&gt;一、简答题&lt;/p&gt;
&lt;p&gt;1、当前计算机系统一般会采用层次结构存储数据，请介绍下典型计算机存储系统一般分为哪几个层次，为什么采用分层存储数据能有效提高程序的执行效率?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目前，在计算机系统中通常采用三级层次结构来构成存储系统，主要由高速缓冲存储器Cache、主存储器和辅助存储器组成,存储系统多级层次结构中，由上向下分三级，其容量逐渐增大，速度逐级降低，成本则逐次减少,整个结构又可以看成两个层次：它们分别是主存一辅存层次和cache一主存层次,一个较大的存储系统是由各种不同类型的存储设备构成，是一个具有多级层次结构的存储系统。该系统既有与CPU相近的速度，又有极大的容量，而成本又是较低的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、Unix/Linux系统中僵尸进程是如何产生的？有什么危害？如何避免？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个进程在调用exit命令结束自己的生命的时候，其实它并没有真正的被销毁，而是留下一个称为僵尸进程
的数据结构,在Linux进程的状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所有内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不再占有任何内存空间。它需要它的父进程来为它收尸，如果他的父进程没安装SIGCHLD信号处理函数调用wait或waitpid()等待子进程结束，又没有显式忽略该信号，那么它就一直保持僵尸状态，如果这时父进程结束了，那么init进程自动会接手这个子进程，为它收尸，它还是能被清除的。但是如果如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是为什么系统中有时会有很多的僵尸进程。&lt;/p&gt;
&lt;p&gt;避免方法：&lt;/p&gt;
&lt;p&gt;在SVR4中，如果调用signal或sigset将SIGCHLD的配置设置为忽略,则不会产生僵死子进程&lt;/p&gt;
&lt;p&gt;调用fork两次。&lt;/p&gt;
&lt;p&gt;用waitpid等待子进程返回. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3、简述Unix/Linux系统中使用socket库编写服务器端程序的流程，请分别用对应的socket通信函数表示？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;服务器端流程如下：&lt;/p&gt;
&lt;p&gt;1.创建serverSocket&lt;/p&gt;
&lt;p&gt;2.初始化 serverAddr（服务器地址）&lt;/p&gt;
&lt;p&gt;3.将socket和serverAddr 绑定 bind&lt;/p&gt;
&lt;p&gt;4.开始监听 listen&lt;/p&gt;
&lt;p&gt;5.进入while循环，不断的accept接入的客户端socket，进行读写操作write和read&lt;/p&gt;
&lt;p&gt;6.关闭serverSocket&lt;/p&gt;
&lt;p&gt;客户端流程：&lt;/p&gt;
&lt;p&gt;1.创建&lt;code&gt;clientSocket&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2.初始化&lt;code&gt;serverAddr&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3.链接到服务器 &lt;code&gt;connect&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4.利用write和read 进行读写操作&lt;/p&gt;
&lt;p&gt;5.关闭clientSocke&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;二、算法与程序设计题&lt;/p&gt;
&lt;p&gt;1、使用C/C++编写函数，实现字符串反转，要求不使用任何系统函数，且时间复杂度最小，函数原型：&lt;code&gt;char* reverse_str(char* str)&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;获取首尾指针，然后将首尾指针指向的元素交换，将首指针指向下一个，将尾指针指向前一个，交换指针指向的元素，然后重复执行，直到首尾指针相遇。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、给定一个如下格式的字符串&lt;code&gt;(1,(2,3),(4,(5,6),7))&lt;/code&gt;括号内的元素可以是数字，也可以是另一个括号，请实现一个算法消除嵌套的括号，比如把上面的表达式变成：&lt;code&gt;(1,2,3,4,5,6,7)&lt;/code&gt;，如果表达式有误请报错&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用栈和队列实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3、题如下图所示&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2013/12/baidu_2014_A.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/job/baidu2014_1.jpg" width="100%"/&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;三、系统设计题&lt;/p&gt;
&lt;p&gt;在企业中，对生产数据进行分析具有很重要的意义，但是生产数据通常不能直接用于数据分析，通常需要进行抽取、转换和加载，也就是通常说的ETL。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2013/12/baidu_2014_A.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/job/baidu2014_2.jpg"/&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为了便于开发和维护，并提高数据实时性，通常将一个完整的ETL过程分为多个任务，组成流水线，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2013/12/baidu_2014_A.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/job/baidu2014_3.jpg"/&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;假设任务定义和任务之间的依赖关系都保存在文件中，文件格式分别如下：&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2013/12/baidu_2014_A.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/job/baidu2014_4.jpg"/&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;p&gt;1、下面是ETL调度系统的模块图，请描述各个模块呃主要职责，以及各个线条的 含义。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2013/12/baidu_2014_A.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/job/baidu2014_4.jpg"/&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、 添加依赖关系时要避免出现环，假设系统同一个时刻只允许一个人添加任务依赖，请实现一个函数来检查新的依赖是否导致环，依赖的上游存在环会导致非正常的调度，因此也希望能避免。（10分）&lt;/p&gt;
&lt;p&gt;函数名：checkCycle&lt;/p&gt;
&lt;p&gt;输入：pairs，已存在的依赖关系&lt;code&gt;((pre,post)……)&lt;/code&gt;, &lt;code&gt;newPair&lt;/code&gt;新的依赖关系&lt;code&gt;(pre,post)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输出：True: 不存在环，False: 存在环&lt;/p&gt;
&lt;p&gt;3、 如果调度时，某个任务在其依赖的任务之前执行，必然导致错误，请实现调度算法，确保任务按照依赖顺序执行?&lt;/p&gt;
&lt;p&gt;函数名：&lt;code&gt;schedule&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输入1：tasks，整数数组；&lt;/p&gt;
&lt;p&gt;输入2：&lt;code&gt;task-relation&lt;/code&gt;，二元组数组，每个二元组表示一组关系&lt;/p&gt;
&lt;p&gt;输出：&lt;code&gt;task id&lt;/code&gt;序列，并行执行的用","分隔，其他的用";"分隔&lt;/p&gt;
&lt;p&gt;4、 给定一个任务，如何计算出他的最晚完成时间?&lt;/p&gt;
&lt;p&gt;函数名：&lt;code&gt;calMaxEndTime&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输入1：&lt;code&gt;tasks&lt;/code&gt;，3元组数组，&lt;code&gt;（task_id, start_time, max_run_time）&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输入2：&lt;code&gt;task-relations&lt;/code&gt;，二元组数组，每个二元组表示一组关系&lt;/p&gt;
&lt;p&gt;输入3：&lt;code&gt;task-id&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输出：最晚完成时间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇答案不全，希望有时间的同学补全&lt;/strong&gt;&lt;/p&gt;</summary><category term="百度"></category></entry><entry><title>2014年暴风笔试试卷A</title><link href="http://www.yanyulin.info/pages/2013/11/baofeng_2014_A.html" rel="alternate"></link><updated>2013-11-23T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2013-11-23:pages/2013/11/baofeng_2014_A.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;如有错误，或更加精简的方法，请留言，我会更正，以方便更多的人
暴风影音2014年A郑，据说可以解决&lt;code&gt;户口&lt;/code&gt;
注:以下如无特殊说明，均假设计算机编程环境为&lt;code&gt;intel x86&lt;/code&gt;的&lt;code&gt;32位CPU&lt;/code&gt;,编译器为VS,编程语言首选C语言，也可以使用自已熟悉的编程语言。&lt;/p&gt;
&lt;p&gt;1、已知一个二叉树的先序遍历和中序遍历得到的序列为&lt;code&gt;ABDEGCFH&lt;/code&gt;和&lt;code&gt;DBGEAFHC&lt;/code&gt;，请:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1:根据先序遍历和中序遍历计算出该二叉树的结构图&lt;/p&gt;
&lt;p&gt;2:根据1的结果，计算该二叉树的后序遍历后序遍历结果&lt;/p&gt;
&lt;p&gt;3:完成后序遍历代码（不得使用迭代函数）&lt;/p&gt;
&lt;p&gt;答案如下&lt;/p&gt;
&lt;p&gt;1:结构图如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2013/11/baofeng_2014_A.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/daan/bd1.jpg"/&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2:后序遍历结果是&lt;code&gt;DGEBHFCA&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3:代码如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;postorder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BinarySearchTree&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;BinarySearchTree&lt;/span&gt; &lt;span class="n"&gt;preNode&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;currNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;BinarySearchTrees&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;preNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;currNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;preNode&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;preNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;m_pLeft&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;currNode&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;preNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;m_pRight&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;currNode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;m_pLeft&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;m_pLeft&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;m_pRight&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;m_pRight&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;m_pLeft&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;preNode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;m_pRight&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;currNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;m_pRight&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;currNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;m_nValue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;preNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;currNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2、将内存中一张宽为X，高为Y的RGB32格式的图片向右旋转90度。源地址BYTE &lt;em&gt;pSrc为指向图片的首地址，目标地址BYTE &lt;/em&gt;pDst为输出的目标缓冲区，备注：RGB32是一种图像格式，它用4个连续BYTE来表示一个像素，图片的存储方式为一行一样连续存：
&lt;table border="1px"&gt;
&lt;tr&gt;
&lt;td&gt;
A
&lt;/td&gt;
&lt;td&gt;
B
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;
C
&lt;/td&gt;
&lt;td&gt;
D
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
如上表为宽度为2且高度为2的图像，共4个像素，在内存中存储为&lt;code&gt;A[4]B[4]C[4]D[4]&lt;/code&gt;,&lt;code&gt;void rotate(BYTE *pSrc, BYTE *pDest, int X, int Y){ }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解：此问题先考虑每个像素占一个字节的情况，然后再将问题扩展为占四个字节的情况。假设现在有8个像素，宽度为4高度为2，即&lt;/p&gt;
&lt;p&gt;ABCD&lt;/p&gt;
&lt;p&gt;EFGH&lt;/p&gt;
&lt;p&gt;旋转之后变为宽度为2，高度为4,即&lt;/p&gt;
&lt;p&gt;EA&lt;/p&gt;
&lt;p&gt;FB&lt;/p&gt;
&lt;p&gt;GC&lt;/p&gt;
&lt;p&gt;HD&lt;/p&gt;
&lt;p&gt;A[0][0]-&amp;gt;A[0][1]&lt;/p&gt;
&lt;p&gt;B[0][1]-&amp;gt;B[1][1]&lt;/p&gt;
&lt;p&gt;C[0][2]-&amp;gt;C[2][1]&lt;/p&gt;
&lt;p&gt;D[0][3]-&amp;gt;D[3][1]&lt;/p&gt;
&lt;p&gt;E[1][0]-&amp;gt;E[0][0]&lt;/p&gt;
&lt;p&gt;F[1][1]-&amp;gt;F[0][1]&lt;/p&gt;
&lt;p&gt;G[1][2]-&amp;gt;G[0][2]&lt;/p&gt;
&lt;p&gt;H[1][3]-&amp;gt;H[0][3]&lt;/p&gt;
&lt;p&gt;第0行的变为了第&lt;code&gt;(x-1)&lt;/code&gt;列，其中原矩阵中的列号与旋转矩阵的行号相同，第&lt;code&gt;（x-1）&lt;/code&gt;行变换为了第0行，其中原矩阵的列号与旋转矩阵的行号相同这里用i表示行，j表示列，则旋转后的&lt;code&gt;pDest[j][x-i-1] = pSrc[i][j]&lt;/code&gt;，然后将其扩展为4字节问题，即赋值时要一次性复制4字节。代码如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;BYTE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//4字节&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;rotate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;BYTE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pSrc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BYTE&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pDest&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;dpos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;spos&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;//每次复制4个字节&lt;/span&gt;
                &lt;span class="n"&gt;pDest&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;dpos&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pSrc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;spos&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3、给定字符串A和B，输出A和B中第一个最长公共子串，比如A="wepiabc"，B="pabcni"则输出“abc”&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#define MAXLEN 50&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;LCS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;[][&lt;/span&gt;&lt;span class="n"&gt;MAXLEN&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;len_a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;len_b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;len_a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;len_b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      
    &lt;span class="n"&gt;max&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;len_a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;len_b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                    &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="k"&gt;else&lt;/span&gt;
                    &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="n"&gt;max&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
                    &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;4、 TCP建立连接需要几次握手过程？为什么会采用这么多次握手，请简述过程。若最后一次握手失败，会怎样处理?&lt;/p&gt;
&lt;p&gt;解：TCP建立连接需要3次握手,过程如下图所示，第三次握手失败，服务器端处于SYN_RCVD状态，服务器端发送复位报文请求建立连接。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.yanyulin.info/pages/2013/11/baofeng_2014_A.html"&gt;
&lt;img src="http://www.yanyulin.info/pics/daan/bd2.jpg"/&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、ClassA是一个类，那么语句ClassA a, *b[2], c[3], &amp;amp;d = a;执行时调用到ClassA的构造函数次数为&lt;/p&gt;
&lt;p&gt;解:4次&lt;/p&gt;
&lt;p&gt;6、32位系统中&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="c1"&gt;//4字节&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//4字节&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//4字节&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="n"&gt;sT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;请问sizeof(sT)=?多少&lt;/p&gt;
&lt;p&gt;解:12&lt;/p&gt;
&lt;p&gt;7、甲和乙进行打靶比赛，各打两发子弹，中靶数量最多的人获胜，甲每发子弹中弹的概率是60%，而乙每发子弹中靶的概率是30%，则比赛中乙战胜甲的可能性(&lt;code&gt;C&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A&lt;/code&gt; 小于5%    &lt;code&gt;B&lt;/code&gt; 在5%~12%之间  &lt;code&gt;C&lt;/code&gt; 在10%~15%之间    &lt;code&gt;D&lt;/code&gt; 大于15%&lt;/p&gt;
&lt;p&gt;8、请回答下列程序执行后的输出结果&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;this is a string!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;memcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解:因为B是野指针，会导致运行时错误。&lt;/p&gt;
&lt;p&gt;9、分别指出下列操作系统是哪一种类型？（单用户单任务/单用户多任务/多用户单任务/多用户多任务）&lt;/p&gt;
&lt;p&gt;DOS、Windows 7、Windows 2003、Linux、Unix&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DOS&lt;/code&gt;：单用户单任务&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Windows 7&lt;/code&gt;：多用户多任务&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Linux、Unix&lt;/code&gt;：多用户多任务&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Windows 2003(Windows Server 2003)&lt;/code&gt;：多用户多任务&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Windows XP&lt;/code&gt;及以前&lt;code&gt;Windows&lt;/code&gt;版本：单用户多任务&lt;/p&gt;</summary><category term="暴风"></category></entry><entry><title>2014年华为校招机试(一)</title><link href="http://www.yanyulin.info/pages/2013/11/huawei_2014_1.html" rel="alternate"></link><updated>2013-11-18T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2013-11-18:pages/2013/11/huawei_2014_1.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;通过键盘输入一串小写字母(a~z)组成的字符串。请编写一个字符串过滤程序，若字符串中出现多个相同的字符，将非首次出现的字符过滤掉。
比如字符串“abacacde”过滤结果为“abcde”。
要求实现函数：&lt;code&gt;void stringFilter(const char *pInputStr, long lInputLen, char *pOutputStr)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输入&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pInputStr&lt;/code&gt;：输入字符串&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lInputLen&lt;/code&gt;：  输入字符串长度       &lt;/p&gt;
&lt;p&gt;输出  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;pOutputStr&lt;/code&gt;： 输出字符串，空间已经开辟好，与输入字符串等长；&lt;/p&gt;
&lt;p&gt;注意 只需要完成该函数功能算法，中间不需要有任何IO的输入输出&lt;/p&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;p&gt;输入：“deefd”        输出：“def”&lt;/p&gt;
&lt;p&gt;输入：“afafafaf”     输出：“af”&lt;/p&gt;
&lt;p&gt;输入：“pppppppp”     输出：“p”&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="vi"&gt;#include&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;algorithm&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="vi"&gt;#include&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;iostream&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nx"&gt;using&lt;/span&gt; &lt;span class="nx"&gt;namespace&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="bp"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;stringFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;pInputStr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;long&lt;/span&gt; &lt;span class="nx"&gt;lInputLen&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;pOutputStr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nb"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;lInputLen&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;find&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;pInputStr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;pInputStr&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;pInputStr&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;)==pInputStr+i)
            *pOutputStr++=pInputStr&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通过键盘输入一串小写字母(a~z)组成的字符串。请编写一个字符串压缩程序，将字符串中连续出席的重复字母进行压缩，并输出压缩后的字符串。&lt;/p&gt;
&lt;p&gt;压缩规则：仅压缩连续重复出现的字符。比如字符串"abcbc"由于无连续重复字符，压缩后的字符串还是"abcbc"。&lt;/p&gt;
&lt;p&gt;压缩字段的格式为"字符重复的次数+字符"。例如：字符串"xxxyyyyyyz"压缩后就成为"3x6yz"。&lt;/p&gt;
&lt;p&gt;要求实现函数：&lt;code&gt;void stringZip(const char *pInputStr, long lInputLen, char *pOutputStr);&lt;/code&gt;
&lt;code&gt;pInputStr&lt;/code&gt;：输入字符串&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lInputLen&lt;/code&gt;：输入字符串长度&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pOutputStr&lt;/code&gt;： 输出字符串，空间已经开辟好，与输入字符串等长；&lt;/p&gt;
&lt;p&gt;注意只需要完成该函数功能算法，中间不需要有任何IO的输入输出&lt;/p&gt;
&lt;p&gt;示例 &lt;/p&gt;
&lt;p&gt;输入：“cccddecc”   输出：“3c2de2c”&lt;/p&gt;
&lt;p&gt;输入：“adef”     输出：“adef”&lt;/p&gt;
&lt;p&gt;输入：“pppppppp” 输出：“8p”&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;stringZip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pInputStr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;lInputLen&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pOutputStr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;lInputLen&lt;/span&gt;&lt;span class="p"&gt;;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;lInputLen&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pInputStr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;pInputStr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pOutputStr&lt;/span&gt;&lt;span class="o"&gt;++=&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;48&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pOutputStr&lt;/span&gt;&lt;span class="o"&gt;++=&lt;/span&gt;&lt;span class="n"&gt;pInputStr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pOutputStr&lt;/span&gt;&lt;span class="o"&gt;++=&lt;/span&gt;&lt;span class="n"&gt;pInputStr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="华为"></category></entry><entry><title>2013年谷歌校招笔试(一)</title><link href="http://www.yanyulin.info/pages/2013/06/google_2013_1.html" rel="alternate"></link><updated>2013-06-11T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2013-06-11:pages/2013/06/google_2013_1.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;一：单选题&lt;/p&gt;
&lt;p&gt;1：使用C语言将一个1G字节的数组从头到尾全部设置为’A’,在一台典型的当代PC上，需要花费的CPU时间的数量级最接近：(&lt;code&gt;B&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;A 0.001秒 B 1秒 C 100秒 D 2小时&lt;/p&gt;
&lt;p&gt;2：在某些极端要求性能的场合，我们需要对程序进行优化，关天优化，以下说法正确的是(&lt;code&gt;D&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;A 将程序整个用汇编语言改写会大大提高程序性能&lt;/p&gt;
&lt;p&gt;B 在优化前，可以先确定哪部分代码最费时，然后对这部份代码用汇编改写，使用汇编的语句越少，程序运行的越快。&lt;/p&gt;
&lt;p&gt;C:使用汇编语句虽然可以提高程序的性能，但会降低程序的可移植性，所以应该绝对避免&lt;/p&gt;
&lt;p&gt;D:适当调整汇编指令的顺序，可以缩短程序的运行时间 &lt;/p&gt;
&lt;p&gt;3:对如下C语言程序在普通的X86PC上运行输出正确的是(&lt;code&gt;B&lt;/code&gt;)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;Char&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;512&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;Sprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="n"&gt;world&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;Return&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;Main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A 程序可能崩溃，也可能输出&lt;code&gt;hello world&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;B 程序可能崩溃，也可能输出 &lt;code&gt;world&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;C 程序可能崩溃，也可能输出&lt;code&gt;hello&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;D 程序一定崩溃&lt;/p&gt;
&lt;p&gt;4:方程&lt;code&gt;X1+X2+X3+X4=30&lt;/code&gt;,有多少满足&lt;code&gt;X1&amp;gt;=2,X2&amp;gt;=0,X3&amp;gt;=-5,X4&amp;gt;=8&lt;/code&gt;的整数解（&lt;code&gt;A&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;A 3276  B:3654 C:2925 D:17550&lt;/p&gt;
&lt;p&gt;5:一个袋子里装了100个苹果，100个香蕉，100个桔子，100个梨，如果每分钟从里面随机抽取一种水果，那么最多过多少分钟肯定至少能拿到一打相同种类的水果(1打=12)（&lt;code&gt;D&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;A:40 B:12 C:24 D:45&lt;/p&gt;
&lt;p&gt;6:双败淘汰赛与淘汰赛相仿，也是负者出局，但负一场并未淘汰，只是跌入负者组，在负者组再负者（即总共已负两场）才被淘汰，现在有10个人来参加又败淘汰赛，假设我们取消最后胜利组冠军的比赛，那么一共需要多少场比赛？（&lt;code&gt;B&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;A:16 B:17 C:18 D:19 E:20&lt;/p&gt;
&lt;p&gt;7:n个结点的二叉树，最多可以有多少层(&lt;code&gt;D&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;A: n/2 B:log(n) C:n-1 D:n&lt;/p&gt;
&lt;p&gt;8:下面哪一个序列不是上图的一个拓扑排序？（&lt;code&gt;C&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;A:ebfgadch B:aebdfch C:adchebfg D:aedbfgch&lt;/p&gt;
&lt;p&gt;9：假如某主机安装了2GB内存，在其上运行的某支持MMU的32位Linux发行版中，一共运行了X,Y,Z三个进程，下面关于三个进程使用的内存方式，哪个是可行的(&lt;code&gt;D&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;A.X,Y,Z的虚拟地址空间都映射到0-4G的虚拟地址上&lt;/p&gt;
&lt;p&gt;B.X在堆上分配总大小为1GB的空间，Y在堆上分配200MB,Z在堆上分配500MB，并且内存映射访问一个1GB的文件。&lt;/p&gt;
&lt;p&gt;C.X在堆上分配1GB,Y在堆上分配800MB,Z在堆上分配400MB&lt;/p&gt;
&lt;p&gt;D.以上访问方式都是可行的&lt;/p&gt;
&lt;p&gt;10：当使用TCP协议编程时，下列问题哪个是由程序员考虑和处理的(&lt;code&gt;D&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;A:乱序数据包的传递 &lt;/p&gt;
&lt;p&gt;B数据传输过程中的纠错 &lt;/p&gt;
&lt;p&gt;C:网络拥塞处理 &lt;/p&gt;
&lt;p&gt;D:发送数据的格式与应用层的协议&lt;/p&gt;
&lt;p&gt;二：程序设计与算法&lt;/p&gt;
&lt;p&gt;1：给定三个整数a,b,c实现函数int median(int a,int b,int c),返回三个数的中位数，不可以使用sort,要求整数操作（比较,位运行，加减乘除)次数尽量少，并分析说明程序最坏和平均情况下使用的操作次数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;median&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;abMax&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;acMax&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;abMax&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="n"&gt;acMax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;abMax&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;acMax&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt;&lt;span class="n"&gt;abMax&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;acMax&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2：给定一个key(只含有ASCII编码的小写英文字母),例如kof，然后对input的string(只含有ASCII编码的小写英文字母)利用这个key进行排序，顺序是:先按照key中的字符顺序，然后对key中不包含key的字符，按a-z排序&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="vi"&gt;#include&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;iostream&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="vi"&gt;#include&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;algorithm&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="vi"&gt;#include&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="bp"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;h&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nx"&gt;using&lt;/span&gt; &lt;span class="nx"&gt;namespace&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nx"&gt;char&lt;/span&gt; &lt;span class="nb"&gt;key&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;=&amp;quot;kof&amp;quot;;
char str&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;=&amp;quot;wqtewqtewkwetiowoweff&amp;quot;;
sort(str,str+strlen(str));
int flag=0;
for(int i=0;i&lt;span class="nt"&gt;&amp;lt;strlen&lt;/span&gt;&lt;span class="err"&gt;(&lt;/span&gt;&lt;span class="na"&gt;key&lt;/span&gt;&lt;span class="err"&gt;);&lt;/span&gt;&lt;span class="na"&gt;i&lt;/span&gt;&lt;span class="err"&gt;++)&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;
&lt;span class="na"&gt;for&lt;/span&gt;&lt;span class="err"&gt;(&lt;/span&gt;&lt;span class="na"&gt;int&lt;/span&gt; &lt;span class="na"&gt;j=&lt;/span&gt;&lt;span class="s"&gt;0;j&amp;lt;strlen(str);j++)&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;
&lt;span class="na"&gt;if&lt;/span&gt;&lt;span class="err"&gt;(&lt;/span&gt;&lt;span class="na"&gt;key&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="na"&gt;=&lt;/span&gt;&lt;span class="s"&gt;=str&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="s"&gt;)&lt;/span&gt;
&lt;span class="err"&gt;{&lt;/span&gt;
&lt;span class="na"&gt;for&lt;/span&gt;&lt;span class="err"&gt;(&lt;/span&gt;&lt;span class="na"&gt;int&lt;/span&gt; &lt;span class="na"&gt;k=&lt;/span&gt;&lt;span class="s"&gt;j;k&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;flag;k--)
{
str&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;=str&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;;
}
str&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;flag&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;=key&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;;
++flag;
}
}
}
&lt;/pre&gt;&lt;/div&gt;</summary><category term="谷歌"></category></entry><entry><title>2013年华为校招机试(一)</title><link href="http://www.yanyulin.info/pages/2013/06/huawei_2013_1.html" rel="alternate"></link><updated>2013-06-11T00:00:00+08:00</updated><author><name>烟雨林</name></author><id>tag:www.yanyulin.info,2013-06-11:pages/2013/06/huawei_2013_1.html</id><summary type="html">&lt;hr /&gt;
&lt;p&gt;通过键盘输入任意一个字符串序列，字符串可能包含多个子串，子串以空格分隔，请编写一个程序，自动分离出各个子串，并使用’,’将其分隔，并且在最后也补充一个’,’，并将子串存储。&lt;/p&gt;
&lt;p&gt;如果输入&lt;code&gt;”abc def ghi d”&lt;/code&gt;,结果将是&lt;code&gt;abc,def,gh,i,d&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;要求实现函数&lt;code&gt;Void DivideString(const char *pInputStr,long IinputLen,char *pOutputStr);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pInputStr&lt;/code&gt;:输入字符串&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IinputLen&lt;/code&gt;:输入字符串的长度&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pOutputStr&lt;/code&gt;:输出字符串，字符串已开辟好，与输入字符串等长&lt;/p&gt;
&lt;p&gt;注意：只需要完成该函数功能算法，中间不需要有任何IO的输入输出&lt;/p&gt;
&lt;p&gt;解，首先去掉字符串前面开始的空格，然后遍历字符串，遇到空格时，将标志设为真，先不处理，等下次时循环时，若标志为真，则在字符前加一,号即可&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;DivideString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pInputStr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;IinputLen&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;OutputStr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//计数&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pInputStr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;//去掉前面的空格&lt;/span&gt;
&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;IinputLen&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pInputStr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;continue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="c1"&gt;//如果flag为true,说明有空格，则将空格变成了, &lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="o"&gt;=!&lt;/span&gt;&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;OutputStr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;OutputStr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;pInputStr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;OutputStr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;二:将一个字符串中出现次数最少的字符删掉，并保证删除后的字符顺序不变，如果出现次数最少的字符有多种，则这几种字符都要删除，该字符串长度不会超过20个字符。 例如：源字符串为&lt;code&gt;“abcdd”&lt;/code&gt;，删除后为&lt;code&gt;“dd”&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;解：此题主要是内存移位操作&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;deleteMin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;InputSrc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ILen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sz&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//最小出现次数&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ILen&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;sz&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;InputSrc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sz&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;sz&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;sz&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InputSrc&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sz&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;InputSrc&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;memcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InputSrc&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;InputSrc&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;ILen&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//因为跳过了一位&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;InputSrc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</summary><category term="华为"></category></entry></feed>