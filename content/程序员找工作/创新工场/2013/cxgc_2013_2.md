Date: 2014-03-09
Title: 创新工场校园招聘笔试题2013年软件研发
Category: 程序员找工作
Tags: 创新工场笔试题
Slug: cxgc_2013_B
Img:pics/cxgc.jpg
summary:有关多线程，多进程的描述错误的是，我们需要监听一个事件状态，让它在状态发生改变时主动发出通知，请问需要哪种设计模式？有`2012`瓶矿泉水，其中有一瓶有毒，请问需要多少只老鼠才能一次性找到有毒的矿泉水？有1分,2分,5分,10分四种硬币，每种硬币数量无限，给定n分钱，求有多少种组合可以组合成n分钱？马戏团里有...

----------
**如有错误，或更加精简的方法，请留言，我会更正，以方便更多的人**

**时间：2012年9月27日 地点：鼎好大厦10层**

**考试时长：1小时**

**第一部份选择题**

1，阅读以下程序，求z的结果

    #define N 3  
    #define Y(n) ((N+1)*n)  
    z = 2*（N+Y(5+1)）;  

解析48


2有关多线程，多进程的描述错误的是

A）子进程获得父进程的数据空间，堆和栈的复制品

B）线程可以与同进程的其他线程共享数据，但是它拥有自己的栈空间且拥有独立的执行序列

C）线程执行开销小，但是不利于资源管理和保护

D）进程适合在SMP机器上进行，而线程则可以跨机器迁移

解答：D

3、求sizeof（s）

    struct s
    {  int x:3;
       int y:4;
       int z:5;
     double a;
    }

解答：16

4、序列`{2,1,4,9,8,10,6,20}`是某排序算法第二轮排序的结果，则该算法只能是

`A快速排序 `  

B冒泡排序

C选择排序    

D插入排序

5、我们需要监听一个事件状态，让它在状态发生改变时主动发出通知，请问需要哪种设计模式？

A装饰者模式 

B建造者模式

C创新工场模式

D观察者模式

解答：D

6、有2012瓶矿泉水，其中有一瓶有毒，请问需要多少只老鼠才能一次性找到有毒的矿泉水？

解答：11只

二 问答题

1、有0-n这n+1个数，但是其中丢了一个数，请问如何找出丢了哪个数？

解答：求这n个数的sum，然后计算n(n+1)/2-sum可得。

2、 解释`#typedef char (*func)(int,char*)`

解答：定义了一个函数指针的数据类型；该数据类型可以用来定义函数指针；定义的函数指针指向的函数的参数为`(int,char*)`

3、求以下程序输出结果

    int a[2][2][3]= { {{1,2,3},{4,5,6}},{{7,8,9},{10,11,12}}};
    int *ptr=(int *)(&a+1);
    printf(“%d %d”, *(int*)(a+1), *(ptr-1));

解答：

考察多级指针，一定要明确指针指向的是什么，才能知道它加1后跳过了多少字节。&a是个四级指针，指向的是a这样的数组，所以它加1，就会跳过整个数组。

4、求以下程序输出结果

    #include <iostream>
    using namespace std;
    class A
    {
    public:
    	virtual void print()
    	{ cout << "A::print()" <<endl;}
    };
    class B: public A
    {
    public:
    	virtual void print()
    	{ cout << "B::print()" <<endl;}
    };
    class C: public A
    {
    public:
    	virtual void print()
    	{ cout << "C::print()" <<endl;}
    };
    void print(A a)
    {
    	a.print();
    }
    void main()
    {
    	A a,*aa,*ab,*ac;
    	B b;
    	C c;
    	aa=&a;
    	ab=&b;
    	ac=&c;
    	a.print();
    	b.print();
    	c.print();
    	aa->print();
    	ab->print();
    	ac->print();
    	print(a);
    	print(b);
    	print(c);
    }
 
解答：

    A::print();
    
    B::print();
    C::print();
    A::print();
    
    B::print();
    C::print();
    
    A::print();
    A::print();
    A::print();

三算法编程题

1，有1分,2分,5分,10分四种硬币，每种硬币数量无限，给定n分钱，求有多少种组合可以组合成n分钱？

解答：

思路： 

1、四层循环

2、使用回溯法在空间中搜索

代码为思路2：

    #include "stdafx.h"
    #include <vector>
    #include <iostream>
    using namespace std;
    
    int count=0;
    int Target=0;
    
    int coin[4]={1,2,5,10};
    int total=0;
    vector<int> solution;
    
    void dfs(int index)
    {
    	if( total == Target )
    	{
    		count++;
    		cout << count <<":" ;
    		for( int i=0; i<(int)solution.size(); i++)
    		{
    			cout  << solution[i]<<" ";
    		}
    		cout << endl;
    		return;
    	}
    
    	if( total > Target )
    		return;
    
    	for( int i=index; i<4; i++)
    	{
    		total += coin[i];
    		solution.push_back( coin[i] );
    		dfs(i);
    		solution.pop_back();
    		total -=coin[i];
    	}
    }
    
    int _tmain(int argc, _TCHAR* argv[])
    {
    	while(1)
    	{
    		count=0;
    		cin >> Target;
    		dfs(0);
    		cout << count <<endl;
    	}
    	return 0;
    }

2、马戏团里有个叠罗汉的表演，为了便于美观，下面的人身高和体重都要大于上面的人。现在知道n个演员的身高和体重，请问最多能叠多少层？

解答：

思路：

首先生成一个有向图，用连接矩阵的方式来表示。map[i][j]==1表示第i个人上面可以放第j个人。然后开始对每个人进行深度搜索，这个图中不可能有环。所以对于每个人来说就是一棵树，搜索树的高度，再找出最高的高度即是答案。

    #include "stdafx.h"
    #include <iostream>
    #include <fstream>
    #include <vector>
    #include <cstdlib>
    using namespace std;
    
    int N=0;
    double *weight;
    double *height;
    
    int **map;
    int maxDepth=0;
    
    vector<int> bestPath;
    
    int dfs( int index, vector<int> &path )
    {
    	int flag=0;
    	int depth = 0;
    	vector<int> bestPath;
    	for( int i=0; i<N;i++)
    	{
    		if( map[index][i] != 0)
    		{ 
    			flag = 1;
    			vector<int> tPath;
    			int t = dfs(i, tPath);
    			if( t > depth )
    			{
    				path = tPath;
    				depth = t;
    			}
    		}
    	}
    
    	if( flag==0 )
    	{	
    		path.clear();
    		path.push_back(index);
    		return 1;
    	}
    	else
    	{
    //		path = bestPath;
    		path.push_back(index);
    		return depth+1;
    	}
    }
    
    void CreateMap()
    {
    	map = new int*[N];
    
    	for( int i=0; i<N; i++)
    	{
    		map[i] = new int [N];
    		memset( map[i], 0, N*sizeof(int) );
    	}
    
    	for( int i=0; i<N; i++)
    	{
    		for( int j=0; j<N; j++)
    		{
    			if( weight[j]<weight[i] && height[j]<height[i] )
    				map[i][j]=1;
    		}
    	}
    }
    
    void CreateData()
    {
    	ofstream out( "in.txt" );
    	int N = 30;
    	out << N <<endl;
    	for( int i=0; i<N; i++)
    		out << rand() << " ";
    	out << endl;
    
    	for( int i=0; i<N; i++)
    		out << rand() << " ";
    }
    
    int main()
    {
    	CreateData();	
    	freopen( "in.txt", "r", stdin );
    	cout << "Please input N:" <<endl;
    	cin >> N;
    	height = new double[N];
    	weight = new double[N];
    	for( int i=0; i<N; i++)
    		cin >> height[i];
    	for( int i=0; i<N; i++)
    		cin >> weight[i];
    
    	CreateMap();
    	int depth=0;
    	for(int i=0; i<N;i++)
    	{
    		vector<int> tPath;
    		int t=dfs(i,tPath);
    		if( t>depth )
    		{
    			bestPath = tPath;
    			depth = t;
    		}
    	}
    	cout << depth <<endl;
    	for( int i=0; i<(int)bestPath.size(); i++)
    	{
    		cout << height[bestPath[i]]<< " " << weight[bestPath[i]]<<endl;
    	}
    	return 0;
    }

**各位如果有更好的答案，请留言评价，方便更多的人**