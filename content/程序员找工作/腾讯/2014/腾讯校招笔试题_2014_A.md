Date: 2014-03-11
Title: 腾讯校园招聘笔试题目2014年软件研发类武汉
Category: 程序员找工作
Tags: 腾讯笔试题
Slug: tencent_2014_A
Img:pics/tech/qq.jpg
summary:好多题目，都已经记不清了，只记得其中的两道题目，拿来给大家分享一下，有`100W`个关键字，长度小于等于`50`字节。用高效的算法找出top10的热词，并对内存的占用不超过1MB？求二叉树的任意两个节点的最近公共祖先？如果两个节点分别在根节点的左子树和右子树，则返回根节点，如果两个节点都在左子树，则递归处理左子树...

----------

1、有100W个关键字，长度小于等于50字节。用高效的算法找出top10的热词，并对内存的占用不超过1MB？

解析：

>1、先把100W个关键字hash映射到小文件，根据题意，`100W*50B = 50*10^6B = 50M`，而内存只有1M，故干脆搞一个hash函数 `% 50`，分解成50个小文件

>2、针对对每个小文件依次运用`hashmap(key，value)`完成每个key的value次数统计，后用堆找出每个小文件中value次数最大的`top 10`；

>3、最后依次对每两小文件的top 10归并，得到最终的`top 10`
 
2、求二叉树的任意两个节点的最近公共祖先？

解析：递归解法

>1、如果两个节点分别在根节点的左子树和右子树，则返回根节点

>2、如果两个节点都在左子树，则递归处理左子树；如果两个节点都在右子树，则递归处理右子树

参考代码如下：

	bool FindNode(BinaryTreeNode * pRoot, BinaryTreeNode * pNode)
	{
		if(pRoot == NULL || pNode == NULL)
			return false;
	
		if(pRoot == pNode)
			return true;
	
		bool found = FindNode(pRoot->m_pLeft, pNode);
		if(!found)
			found = FindNode(pRoot->m_pRight, pNode);
	
		return found;
	}
	
	BinaryTreeNode * GetLastCommonParent(BinaryTreeNode * pRoot, 
	                                     BinaryTreeNode * pNode1, 
	                                     BinaryTreeNode * pNode2)
	{
		if(FindNode(pRoot->m_pLeft, pNode1))
		{
			if(FindNode(pRoot->m_pRight, pNode2))
				return pRoot;
			else
				return GetLastCommonParent(pRoot->m_pLeft, pNode1, pNode2);
		}
		else
		{
			if(FindNode(pRoot->m_pLeft, pNode2))
				return pRoot;
			else
				return GetLastCommonParent(pRoot->m_pRight, pNode1, pNode2);
		}
	}